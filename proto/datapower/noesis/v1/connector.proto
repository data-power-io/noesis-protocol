// Connector API (gRPC) — with explicit Discovery phase
// ----------------------------------------------------
// Goal:
// - Standardize how a runner talks to a source-specific connector.
// - Support three read modes: FullTable, ChangeStream, Subgraph (graph walk, PLM-friendly).
// - Treat LINKS as first-class entities (with attributes), just like NODES.
//
// Notes:
// - All data records (both NODEs and LINKs) are emitted via the same RecordMsg.
// - Discovery describes the platform, entities, schemas, keys, and per-entity extraction capabilities.
// - Cursors are opaque (connector-defined) but must be stable for resume.
// - Schemas can be provided as Arrow IPC (preferred) or JSON/Avro.
// - Exactly-once end-to-end is a responsibility shared with the runner (Kafka transactions, checkpoints).

syntax = "proto3";

package datapower.noesis.v1;
option go_package = "github.com/data-power-io/noesis-protocol/languages/go/datapower/noesis/v1;noesisv1";
option java_package = "datapower.noesis.v1";
option java_multiple_files = true;

// ===========================
//         SERVICE
// ===========================
service Connector {
  // Light-weight connectivity check (auth/scopes/quota/basic latency).
  rpc Check(CheckRequest) returns (CheckResponse);

  // *** Discovery ***: describe the platform and all available entities, their schemas,
  // keys, and which extraction modes each entity supports.
  rpc Discover(DiscoverRequest) returns (DiscoverResponse);

  // *** Plan Extraction ***: generate extraction splits for parallel data extraction.
  // Returns a list of splits that can be processed independently for batch sources.
  rpc PlanExtraction(PlanExtractionRequest) returns (PlanExtractionResponse);

  // Open a logical reading session (optional; good place to validate config, pin snapshots, warm caches).
  rpc Open(OpenRequest) returns (OpenResponse);

  // Start streaming data according to a plan (full table / change stream / subgraph).
  rpc Read(ReadRequest) returns (stream ReadMessage);

  // Read a specific extraction split (for parallel batch extraction).
  rpc ReadSplit(ReadSplitRequest) returns (stream ReadMessage);

  // Close the session cleanly.
  rpc Close(CloseRequest) returns (CloseResponse);
}

// ===========================
//         DISCOVERY
// ===========================

message DiscoverRequest {
  string tenant_id = 1;                 // For multi-tenant scoping and audit.
  repeated string entity_filter = 2;    // Optional: restrict discovery to these entity names.
  bool include_schemas = 3;             // If false, only metadata is returned (no schema payloads).
}

message DiscoverResponse {
  PlatformInfo platform = 1;            // High-level platform/source info.
  repeated EntityDescriptor entities = 2;// All entities (tables/objects and link-objects).
}

// Platform/source information (useful for logging, governance, and routing).
message PlatformInfo {
  string name = 1;                      // e.g., "Windchill", "Teamcenter", "PostgreSQL"
  string vendor = 2;                    // e.g., "PTC", "Siemens", "PostgreSQL Global Dev"
  string version = 3;                   // e.g., "12.3"
  string timezone = 4;                  // e.g., "UTC"
  map<string, string> tags = 5;         // Free-form: edition, api_tier, region, etc.
}

// An entity is either a business object (NODE) or a link object (LINK) with attributes.
// LINKs must declare their src/dst endpoints (logical FKs).
message EntityDescriptor {
  string name = 1;                      // e.g., "Part", "Document", "BOMLink"
  EntityKind kind = 2;                  // NODE or LINK
  string display_name = 3;              // Human-friendly label
  string description = 4;               // Optional docs

  // Schema in structured format
  StructuredSchemaDescriptor schema = 5;

  // Keys & relational hints.
  repeated string primary_key = 6;      // ["id"] or a composite key
  repeated UniqueKey unique_keys = 7;   // Additional unique constraints
  bool soft_delete = 8;                 // If soft deletes exist
  string soft_delete_field = 9;         // Field name for soft delete marker (e.g., "deleted_at")

  // For LINK (kind=LINK): logical endpoints the link connects (should match target entity PKs).
  LinkEndpoint src = 10;                // Can be empty for NODEs
  LinkEndpoint dst = 11;

  // Supported cursor fields for incremental reads (updated_at, version, LSN, etc.).
  repeated CursorField cursors = 12;

  // Which extraction modes / features are supported by this entity.
  ExtractionCapabilities capabilities = 13;

  // Optional sizing hint.
  int64 estimated_rows = 14;            // Rough estimate if known, otherwise 0
}

enum EntityKind {
  KIND_UNSPECIFIED = 0;
  NODE = 1;
  LINK = 2;
}

// Field type enumeration for common database types
enum FieldType {
  FIELD_TYPE_UNSPECIFIED = 0;
  FIELD_TYPE_STRING = 1;
  FIELD_TYPE_INTEGER = 2;
  FIELD_TYPE_BIGINT = 3;
  FIELD_TYPE_SMALLINT = 4;
  FIELD_TYPE_DECIMAL = 5;
  FIELD_TYPE_FLOAT = 6;
  FIELD_TYPE_DOUBLE = 7;
  FIELD_TYPE_BOOLEAN = 8;
  FIELD_TYPE_DATE = 9;
  FIELD_TYPE_TIME = 10;
  FIELD_TYPE_TIMESTAMP = 11;
  FIELD_TYPE_TIMESTAMP_WITH_TZ = 12;
  FIELD_TYPE_JSON = 13;
  FIELD_TYPE_JSONB = 14;
  FIELD_TYPE_UUID = 15;
  FIELD_TYPE_BINARY = 16;
  FIELD_TYPE_TEXT = 17;
  FIELD_TYPE_ENUM = 18;
  FIELD_TYPE_ARRAY = 19;
}

// Individual field/column descriptor
message FieldDescriptor {
  string name = 1;                          // Field name
  FieldType type = 2;                       // Field type
  bool nullable = 3;                        // Whether field can be NULL
  string default_value = 4;                 // Default value as string
  string documentation = 5;                 // Field documentation/comment

  // Type-specific attributes
  int32 max_length = 6;                     // For STRING/VARCHAR types
  int32 precision = 7;                      // For DECIMAL types
  int32 scale = 8;                          // For DECIMAL types
  repeated string enum_values = 9;          // For ENUM types
  FieldType array_element_type = 10;        // For ARRAY types

  // Position and ordering
  int32 ordinal_position = 11;              // Position in table

  // Metadata
  map<string, string> attributes = 12;      // Connector-specific attributes
}

// Constraint types
enum ConstraintType {
  CONSTRAINT_TYPE_UNSPECIFIED = 0;
  PRIMARY_KEY = 1;
  FOREIGN_KEY = 2;
  UNIQUE = 3;
  CHECK = 4;
  NOT_NULL = 5;
}

// Constraint descriptor
message ConstraintDescriptor {
  string name = 1;                          // Constraint name
  ConstraintType type = 2;                  // Constraint type
  repeated string columns = 3;              // Columns involved

  // Foreign key specific
  string referenced_table = 4;              // For FK constraints
  repeated string referenced_columns = 5;   // For FK constraints
  string on_delete = 6;                     // CASCADE, SET NULL, etc.
  string on_update = 7;                     // CASCADE, SET NULL, etc.

  // Check constraint specific
  string check_expression = 8;              // For CHECK constraints

  // Metadata
  string documentation = 9;                 // Constraint documentation
  map<string, string> attributes = 10;      // Connector-specific attributes
}

// Index descriptor
message IndexDescriptor {
  string name = 1;                          // Index name
  repeated string columns = 2;              // Indexed columns
  bool unique = 3;                          // Whether index is unique
  string type = 4;                          // BTREE, HASH, GIN, etc.
  string condition = 5;                     // Partial index condition
  string documentation = 6;                 // Index documentation
  map<string, string> attributes = 7;       // Connector-specific attributes
}

// Enhanced schema descriptor with structured fields
message StructuredSchemaDescriptor {
  string schema_id = 1;                     // Schema version identifier
  repeated FieldDescriptor fields = 2;      // Field definitions
  repeated ConstraintDescriptor constraints = 3; // Constraints
  repeated IndexDescriptor indexes = 4;     // Indexes
  map<string, string> attributes = 5;       // Table-level attributes
}


message UniqueKey { repeated string columns = 1; }

message LinkEndpoint {
  string entity = 1;                    // Target entity name, e.g., "Part"
  repeated string key_fields = 2;       // Fields in THIS entity that reference the target PK (order must match PK)
}

message CursorField {
  string field = 1;                     // e.g., "updated_at", "version", "lsn"
  CursorType type = 2;
  bool monotonic = 3;                   // True if non-decreasing is guaranteed
}

enum CursorType {
  CURSOR_TYPE_UNSPECIFIED = 0;
  TIMESTAMP = 1;    // e.g., updated_at
  INCREMENTING = 2; // e.g., version number
  LSN = 3;          // Log sequence number (DB log position)
  OPAQUE = 4;       // Connector-defined opaque token
}

// Per-entity capabilities (what this connector can do for that entity).
message ExtractionCapabilities {
  // High-level modes
  bool supports_full_table = 1;
  bool supports_change_stream = 2;
  bool supports_subgraph = 3;          // Typically meaningful for NODEs involved in LINKs

  // Query features
  bool supports_projection = 10;       // Select subset of columns
  bool supports_filter = 11;           // Server-side filtering
  bool supports_ordering = 12;         // Stable ORDER BY on given columns
  repeated string orderable_fields = 13;// Fields that can be used for stable ordering (e.g., PK columns)

  // Subgraph specifics (only relevant if supports_subgraph=true)
  repeated string subgraph_link_entities = 20; // LINK entity names allowed during traversal
  int32 subgraph_max_depth_supported = 21;     // -1 = unlimited; 0 = head only; N = max depth
}

// ===========================
//   CHECK / OPEN / CLOSE
// ===========================
message CheckRequest {
  string tenant_id = 1;
  map<string, string> config = 2;       // Source credentials, endpoints, options
}

message CheckResponse {
  bool ok = 1;
  string message = 2;                   // When not ok: reason
  map<string, string> details = 3;      // Optional more info
}

message OpenRequest {
  string tenant_id = 1;
  map<string, string> config = 2;       // Same config used for Read; connector may pin snapshot here
}

message OpenResponse {
  string session_id = 1;                // Optional logical session id (echo back in logs)
  int64 expires_at_epoch_ms = 2;        // Optional: when the session should be considered stale
}

message CloseRequest { string session_id = 1; }
message CloseResponse {}

// ===========================
//    PLAN EXTRACTION
// ===========================

// Plan parallel extraction for a batch source entity.
// The connector analyzes the entity and returns N independent splits
// that can be extracted in parallel for optimal throughput.
message PlanExtractionRequest {
  string tenant_id = 1;                 // For multi-tenant scoping
  string entity = 2;                    // Entity to extract (e.g., "customers")
  int32 desired_parallelism = 3;        // Hint: how many splits to generate (connector may adjust)
  map<string, string> config = 4;       // Source connection configuration
  Filter filter = 5;                    // Optional: global filter to apply to all splits
  SnapshotOptions snapshot = 6;         // Consistency requirements
}

message PlanExtractionResponse {
  repeated ExtractionSplit splits = 1;  // List of independent extraction splits
  string snapshot_id = 2;               // Optional: snapshot identifier for consistency
  int64 total_estimated_rows = 3;       // Total estimated rows across all splits
}

// Represents an independent unit of work for parallel extraction.
// The split token is opaque and connector-specific (could encode key ranges,
// partition IDs, file paths, etc.)
message ExtractionSplit {
  string split_id = 1;                  // Unique identifier for this split (e.g., "split-0001")
  bytes split_token = 2;                // Opaque connector-specific split metadata
  int64 estimated_rows = 3;             // Estimated rows in this split (0 if unknown)
  map<string, string> metadata = 4;     // Optional split metadata (for logging/debugging)
}

// Read a specific extraction split (for parallel batch extraction).
message ReadSplitRequest {
  string tenant_id = 1;                 // For multi-tenant scoping
  string entity = 2;                    // Entity being extracted
  ExtractionSplit split = 3;            // The split to read
  string snapshot_id = 4;               // Optional: from PlanExtractionResponse
  Projection projection = 5;            // Optional: subset of fields
  RateLimit rate_limit = 6;             // Optional: QPS/parallelism limits
}

// ===========================
//           READ
// ===========================

message ReadRequest {
  string session_id = 1;                // Optional, if Open/Close are used
  // Exactly one mode must be set:
  oneof mode {
    FullTableScan full_table = 10;
    ChangeStream change_stream = 11;
    SubgraphRead subgraph = 12;
  }
  Projection projection = 2;            // Optional: subset of fields to return
  RateLimit rate_limit = 3;             // Optional: QPS/parallelism limits
}

message FullTableScan {
  string entity = 1;                    // Entity name (NODE or LINK)
  Cursor resume_from = 2;               // Opaque cursor for resume (page token, last_pk, etc.)
  Filter filter = 3;                    // Optional server-side filter
  Ordering ordering = 4;                // Stable ordering (e.g., primary key asc)
  SnapshotOptions snapshot = 5;         // How to ensure consistency
}

message ChangeStream {
  string entity = 1;                    // Change feed / CDC for this entity
  Cursor from = 2;                      // Opaque starting position (LSN/offset/timestamp)
  Filter filter = 3;                    // Optional filter (e.g., updated_at >= T)
}

message SubgraphRead {
  repeated Head heads = 1;              // Starting nodes (entity/key)
  Traversal traversal = 2;              // Traversal policy
  SnapshotOptions snapshot = 3;         // Consistent view for nodes+links
  Cursor resume_from = 4;               // Opaque traversal frontier for resume
}

message Head { string entity = 1; string key = 2; }

// Stream payload: schema messages (optional), data records (NODE or LINK), periodic state checkpoints,
// plus logs/metrics for observability.
message ReadMessage {
  oneof msg {
    SchemaMsg schema = 1;               // (Optional) schema broadcast/update
    RecordMsg record = 2;               // Data (NODE or LINK), including deletes
    StateMsg state = 3;                 // Checkpoint (cursor/watermark/group frontier)
    LogMsg log = 4;                     // Structured logs
    MetricMsg metric = 5;               // Simple metrics
  }
}

enum Op {
  OP_UNSPECIFIED = 0;
  UPSERT = 1;
  DELETE = 2;
}

message RecordMsg {
  string entity = 1;                    // e.g., "Part" or "BOMLink"
  string key = 2;                       // Primary key serialized (unique within entity)
  bytes payload = 3;                    // Row payload (Arrow/Avro/JSON — choice must match StructuredSchemaDescriptor)
  string schema_id = 4;                 // Version to validate reader compatibility
  Op op = 5;                            // UPSERT/DELETE
  string group_id = 6;                  // For subgraph: group all records belonging to the same head
  int64 ts_event = 7;                   // Logical event time (watermark) in epoch millis
}

message StateMsg {
  Cursor cursor = 1;                    // Opaque; sufficient to resume without duplication
  int64 watermark = 2;                  // Max logical timestamp observed so far (epoch millis)
  string group_id = 3;                  // For subgraph: optional "group closure" marker
}

// ===========================
//       UTIL / OPTIONS
// ===========================

message Projection { repeated string columns = 1; } // Empty = all columns

// Keep Filter simple and vendor-neutral. Use one of:
// - expression: connector-level expression language or SQL-ish string
// - predicates: a simple list of (field, op, value) triplets (optional to implement)
message Filter {
  string expression = 1; // e.g., "updated_at >= '2024-01-01T00:00:00Z' AND status IN ('A','B')"
  repeated Predicate predicates = 2; // Optional alternative for structured filters
}
message Predicate {
  string field = 1;                   // e.g., "updated_at"
  string op = 2;                      // e.g., ">", ">=", "=", "IN"
  repeated string values = 3;         // string-encoded values
}

message Ordering {
  repeated OrderBy by = 1;            // e.g., [{column:"id", direction:ASC}]
}
message OrderBy {
  string column = 1;
  Direction direction = 2;
}
enum Direction { DIR_UNSPECIFIED = 0; ASC = 1; DESC = 2; }

// Snapshot consistency hints. The connector should pick the strongest available option.
message SnapshotOptions {
  ConsistencyMode mode = 1;           // Desired consistency level
  string as_of = 2;                   // Optional: timestamp/SCN/LSN string for "AS OF" reads
}
enum ConsistencyMode {
  CONSISTENCY_UNSPECIFIED = 0;
  READ_COMMITTED = 1;
  REPEATABLE_READ = 2;
  SNAPSHOT_AS_OF = 3;                 // Point-in-time ("AS OF") if supported
}

message Cursor { bytes token = 1; }    // Opaque, connector-defined

message RateLimit {
  int32 qps = 1;                       // Max requests per second (best-effort)
  int32 parallelism = 2;               // Internal parallelism for fetching
}

// Subgraph traversal policy (PLM/graph scenarios).
message Traversal {
  repeated string allowed_link_entities = 1; // LINK entity names allowed during traversal (e.g., ["BOMLink","PartDocLink"])
  int32 max_depth = 2;                       // -1 = unlimited; 0 = only the head; N = max depth
  TraversalDirection direction = 3;          // OUTBOUND/INBOUND/BOTH
  bool allow_revisit = 4;                    // If false, connector must maintain a visited set
  bool strict_referential_integrity = 5;     // If true, missing references should be surfaced via LOG and/or error policy
}
enum TraversalDirection { TRAV_DIR_UNSPECIFIED = 0; OUTBOUND = 1; INBOUND = 2; BOTH = 3; }

// Optional schema re-broadcast during Read (e.g., on evolution or first message per entity).
message SchemaMsg {
  string entity = 1;
  StructuredSchemaDescriptor schema = 2;
}

// Basic structured logs and lightweight metrics to help with observability.
message LogMsg {
  string level = 1;                    // "INFO","WARN","ERROR","DEBUG"
  string message = 2;
  map<string, string> kv = 3;          // e.g., {"tenant":"t42","entity":"Part","code":"AUTH_RATE_LIMIT"}
}

message MetricMsg {
  string name = 1;                     // e.g., "records_emitted", "api_latency_ms"
  double value = 2;
  map<string, string> tags = 3;        // e.g., {"entity":"Part","mode":"full_table"}
}
