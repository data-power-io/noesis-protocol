// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: datapower/noesis/v1/pipeline.proto

package datapower.noesis.v1;

public interface SourceOrBuilder extends
    // @@protoc_insertion_point(interface_extends:datapower.noesis.v1.Source)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Alias used to reference this source in SQL queries
   * </pre>
   *
   * <code>string alias = 1 [json_name = "alias"];</code>
   * @return The alias.
   */
  java.lang.String getAlias();
  /**
   * <pre>
   * Alias used to reference this source in SQL queries
   * </pre>
   *
   * <code>string alias = 1 [json_name = "alias"];</code>
   * @return The bytes for alias.
   */
  com.google.protobuf.ByteString
      getAliasBytes();

  /**
   * <pre>
   * Type of source (iceberg_table or kafka_topic)
   * </pre>
   *
   * <code>.datapower.noesis.v1.SourceType type = 2 [json_name = "type"];</code>
   * @return The enum numeric value on the wire for type.
   */
  int getTypeValue();
  /**
   * <pre>
   * Type of source (iceberg_table or kafka_topic)
   * </pre>
   *
   * <code>.datapower.noesis.v1.SourceType type = 2 [json_name = "type"];</code>
   * @return The type.
   */
  datapower.noesis.v1.SourceType getType();

  /**
   * <pre>
   * Fully qualified name (e.g., "raw.customers_db" for Iceberg, "raw-orders-events" for Kafka)
   * </pre>
   *
   * <code>string name = 3 [json_name = "name"];</code>
   * @return The name.
   */
  java.lang.String getName();
  /**
   * <pre>
   * Fully qualified name (e.g., "raw.customers_db" for Iceberg, "raw-orders-events" for Kafka)
   * </pre>
   *
   * <code>string name = 3 [json_name = "name"];</code>
   * @return The bytes for name.
   */
  com.google.protobuf.ByteString
      getNameBytes();

  /**
   * <pre>
   * For Iceberg tables that are fed by streaming sources
   * This indicates the table has real-time updates
   * </pre>
   *
   * <code>.datapower.noesis.v1.StreamingSource streaming_source = 4 [json_name = "streamingSource"];</code>
   * @return Whether the streamingSource field is set.
   */
  boolean hasStreamingSource();
  /**
   * <pre>
   * For Iceberg tables that are fed by streaming sources
   * This indicates the table has real-time updates
   * </pre>
   *
   * <code>.datapower.noesis.v1.StreamingSource streaming_source = 4 [json_name = "streamingSource"];</code>
   * @return The streamingSource.
   */
  datapower.noesis.v1.StreamingSource getStreamingSource();
  /**
   * <pre>
   * For Iceberg tables that are fed by streaming sources
   * This indicates the table has real-time updates
   * </pre>
   *
   * <code>.datapower.noesis.v1.StreamingSource streaming_source = 4 [json_name = "streamingSource"];</code>
   */
  datapower.noesis.v1.StreamingSourceOrBuilder getStreamingSourceOrBuilder();

  /**
   * <pre>
   * Schema definition for this source
   * </pre>
   *
   * <code>repeated .datapower.noesis.v1.SchemaField schema = 5 [json_name = "schema"];</code>
   */
  java.util.List<datapower.noesis.v1.SchemaField> 
      getSchemaList();
  /**
   * <pre>
   * Schema definition for this source
   * </pre>
   *
   * <code>repeated .datapower.noesis.v1.SchemaField schema = 5 [json_name = "schema"];</code>
   */
  datapower.noesis.v1.SchemaField getSchema(int index);
  /**
   * <pre>
   * Schema definition for this source
   * </pre>
   *
   * <code>repeated .datapower.noesis.v1.SchemaField schema = 5 [json_name = "schema"];</code>
   */
  int getSchemaCount();
  /**
   * <pre>
   * Schema definition for this source
   * </pre>
   *
   * <code>repeated .datapower.noesis.v1.SchemaField schema = 5 [json_name = "schema"];</code>
   */
  java.util.List<? extends datapower.noesis.v1.SchemaFieldOrBuilder> 
      getSchemaOrBuilderList();
  /**
   * <pre>
   * Schema definition for this source
   * </pre>
   *
   * <code>repeated .datapower.noesis.v1.SchemaField schema = 5 [json_name = "schema"];</code>
   */
  datapower.noesis.v1.SchemaFieldOrBuilder getSchemaOrBuilder(
      int index);

  /**
   * <pre>
   * Optional: Partitioning information for optimization
   * </pre>
   *
   * <code>repeated string partition_keys = 6 [json_name = "partitionKeys"];</code>
   * @return A list containing the partitionKeys.
   */
  java.util.List<java.lang.String>
      getPartitionKeysList();
  /**
   * <pre>
   * Optional: Partitioning information for optimization
   * </pre>
   *
   * <code>repeated string partition_keys = 6 [json_name = "partitionKeys"];</code>
   * @return The count of partitionKeys.
   */
  int getPartitionKeysCount();
  /**
   * <pre>
   * Optional: Partitioning information for optimization
   * </pre>
   *
   * <code>repeated string partition_keys = 6 [json_name = "partitionKeys"];</code>
   * @param index The index of the element to return.
   * @return The partitionKeys at the given index.
   */
  java.lang.String getPartitionKeys(int index);
  /**
   * <pre>
   * Optional: Partitioning information for optimization
   * </pre>
   *
   * <code>repeated string partition_keys = 6 [json_name = "partitionKeys"];</code>
   * @param index The index of the value to return.
   * @return The bytes of the partitionKeys at the given index.
   */
  com.google.protobuf.ByteString
      getPartitionKeysBytes(int index);
}
