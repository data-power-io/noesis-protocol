// Connector API (gRPC) â€” with explicit Discovery phase
// ----------------------------------------------------
// Goal:
// - Standardize how a runner talks to a source-specific connector.
// - Support three read modes: FullTable, ChangeStream, Subgraph (graph walk, PLM-friendly).
// - Treat LINKS as first-class entities (with attributes), just like NODES.
//
// Notes:
// - All data records (both NODEs and LINKs) are emitted via the same RecordMsg.
// - Discovery describes the platform, entities, schemas, keys, and per-entity extraction capabilities.
// - Cursors are opaque (connector-defined) but must be stable for resume.
// - Schemas can be provided as Arrow IPC (preferred) or JSON/Avro.
// - Exactly-once end-to-end is a responsibility shared with the runner (Kafka transactions, checkpoints).

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: datapower/noesis/v1/connector.proto

package noesisv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type EntityKind int32

const (
	EntityKind_KIND_UNSPECIFIED EntityKind = 0
	EntityKind_NODE             EntityKind = 1
	EntityKind_LINK             EntityKind = 2
)

// Enum value maps for EntityKind.
var (
	EntityKind_name = map[int32]string{
		0: "KIND_UNSPECIFIED",
		1: "NODE",
		2: "LINK",
	}
	EntityKind_value = map[string]int32{
		"KIND_UNSPECIFIED": 0,
		"NODE":             1,
		"LINK":             2,
	}
)

func (x EntityKind) Enum() *EntityKind {
	p := new(EntityKind)
	*p = x
	return p
}

func (x EntityKind) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EntityKind) Descriptor() protoreflect.EnumDescriptor {
	return file_datapower_noesis_v1_connector_proto_enumTypes[0].Descriptor()
}

func (EntityKind) Type() protoreflect.EnumType {
	return &file_datapower_noesis_v1_connector_proto_enumTypes[0]
}

func (x EntityKind) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EntityKind.Descriptor instead.
func (EntityKind) EnumDescriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{0}
}

// Field type enumeration for common database types
type FieldType int32

const (
	FieldType_FIELD_TYPE_UNSPECIFIED       FieldType = 0
	FieldType_FIELD_TYPE_STRING            FieldType = 1
	FieldType_FIELD_TYPE_INTEGER           FieldType = 2
	FieldType_FIELD_TYPE_BIGINT            FieldType = 3
	FieldType_FIELD_TYPE_SMALLINT          FieldType = 4
	FieldType_FIELD_TYPE_DECIMAL           FieldType = 5
	FieldType_FIELD_TYPE_FLOAT             FieldType = 6
	FieldType_FIELD_TYPE_DOUBLE            FieldType = 7
	FieldType_FIELD_TYPE_BOOLEAN           FieldType = 8
	FieldType_FIELD_TYPE_DATE              FieldType = 9
	FieldType_FIELD_TYPE_TIME              FieldType = 10
	FieldType_FIELD_TYPE_TIMESTAMP         FieldType = 11
	FieldType_FIELD_TYPE_TIMESTAMP_WITH_TZ FieldType = 12
	FieldType_FIELD_TYPE_JSON              FieldType = 13
	FieldType_FIELD_TYPE_JSONB             FieldType = 14
	FieldType_FIELD_TYPE_UUID              FieldType = 15
	FieldType_FIELD_TYPE_BINARY            FieldType = 16
	FieldType_FIELD_TYPE_TEXT              FieldType = 17
	FieldType_FIELD_TYPE_ENUM              FieldType = 18
	FieldType_FIELD_TYPE_ARRAY             FieldType = 19
)

// Enum value maps for FieldType.
var (
	FieldType_name = map[int32]string{
		0:  "FIELD_TYPE_UNSPECIFIED",
		1:  "FIELD_TYPE_STRING",
		2:  "FIELD_TYPE_INTEGER",
		3:  "FIELD_TYPE_BIGINT",
		4:  "FIELD_TYPE_SMALLINT",
		5:  "FIELD_TYPE_DECIMAL",
		6:  "FIELD_TYPE_FLOAT",
		7:  "FIELD_TYPE_DOUBLE",
		8:  "FIELD_TYPE_BOOLEAN",
		9:  "FIELD_TYPE_DATE",
		10: "FIELD_TYPE_TIME",
		11: "FIELD_TYPE_TIMESTAMP",
		12: "FIELD_TYPE_TIMESTAMP_WITH_TZ",
		13: "FIELD_TYPE_JSON",
		14: "FIELD_TYPE_JSONB",
		15: "FIELD_TYPE_UUID",
		16: "FIELD_TYPE_BINARY",
		17: "FIELD_TYPE_TEXT",
		18: "FIELD_TYPE_ENUM",
		19: "FIELD_TYPE_ARRAY",
	}
	FieldType_value = map[string]int32{
		"FIELD_TYPE_UNSPECIFIED":       0,
		"FIELD_TYPE_STRING":            1,
		"FIELD_TYPE_INTEGER":           2,
		"FIELD_TYPE_BIGINT":            3,
		"FIELD_TYPE_SMALLINT":          4,
		"FIELD_TYPE_DECIMAL":           5,
		"FIELD_TYPE_FLOAT":             6,
		"FIELD_TYPE_DOUBLE":            7,
		"FIELD_TYPE_BOOLEAN":           8,
		"FIELD_TYPE_DATE":              9,
		"FIELD_TYPE_TIME":              10,
		"FIELD_TYPE_TIMESTAMP":         11,
		"FIELD_TYPE_TIMESTAMP_WITH_TZ": 12,
		"FIELD_TYPE_JSON":              13,
		"FIELD_TYPE_JSONB":             14,
		"FIELD_TYPE_UUID":              15,
		"FIELD_TYPE_BINARY":            16,
		"FIELD_TYPE_TEXT":              17,
		"FIELD_TYPE_ENUM":              18,
		"FIELD_TYPE_ARRAY":             19,
	}
)

func (x FieldType) Enum() *FieldType {
	p := new(FieldType)
	*p = x
	return p
}

func (x FieldType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FieldType) Descriptor() protoreflect.EnumDescriptor {
	return file_datapower_noesis_v1_connector_proto_enumTypes[1].Descriptor()
}

func (FieldType) Type() protoreflect.EnumType {
	return &file_datapower_noesis_v1_connector_proto_enumTypes[1]
}

func (x FieldType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FieldType.Descriptor instead.
func (FieldType) EnumDescriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{1}
}

// Constraint types
type ConstraintType int32

const (
	ConstraintType_CONSTRAINT_TYPE_UNSPECIFIED ConstraintType = 0
	ConstraintType_PRIMARY_KEY                 ConstraintType = 1
	ConstraintType_FOREIGN_KEY                 ConstraintType = 2
	ConstraintType_UNIQUE                      ConstraintType = 3
	ConstraintType_CHECK                       ConstraintType = 4
	ConstraintType_NOT_NULL                    ConstraintType = 5
)

// Enum value maps for ConstraintType.
var (
	ConstraintType_name = map[int32]string{
		0: "CONSTRAINT_TYPE_UNSPECIFIED",
		1: "PRIMARY_KEY",
		2: "FOREIGN_KEY",
		3: "UNIQUE",
		4: "CHECK",
		5: "NOT_NULL",
	}
	ConstraintType_value = map[string]int32{
		"CONSTRAINT_TYPE_UNSPECIFIED": 0,
		"PRIMARY_KEY":                 1,
		"FOREIGN_KEY":                 2,
		"UNIQUE":                      3,
		"CHECK":                       4,
		"NOT_NULL":                    5,
	}
)

func (x ConstraintType) Enum() *ConstraintType {
	p := new(ConstraintType)
	*p = x
	return p
}

func (x ConstraintType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ConstraintType) Descriptor() protoreflect.EnumDescriptor {
	return file_datapower_noesis_v1_connector_proto_enumTypes[2].Descriptor()
}

func (ConstraintType) Type() protoreflect.EnumType {
	return &file_datapower_noesis_v1_connector_proto_enumTypes[2]
}

func (x ConstraintType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ConstraintType.Descriptor instead.
func (ConstraintType) EnumDescriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{2}
}

type CursorType int32

const (
	CursorType_CURSOR_TYPE_UNSPECIFIED CursorType = 0
	CursorType_TIMESTAMP               CursorType = 1 // e.g., updated_at
	CursorType_INCREMENTING            CursorType = 2 // e.g., version number
	CursorType_LSN                     CursorType = 3 // Log sequence number (DB log position)
	CursorType_OPAQUE                  CursorType = 4 // Connector-defined opaque token
)

// Enum value maps for CursorType.
var (
	CursorType_name = map[int32]string{
		0: "CURSOR_TYPE_UNSPECIFIED",
		1: "TIMESTAMP",
		2: "INCREMENTING",
		3: "LSN",
		4: "OPAQUE",
	}
	CursorType_value = map[string]int32{
		"CURSOR_TYPE_UNSPECIFIED": 0,
		"TIMESTAMP":               1,
		"INCREMENTING":            2,
		"LSN":                     3,
		"OPAQUE":                  4,
	}
)

func (x CursorType) Enum() *CursorType {
	p := new(CursorType)
	*p = x
	return p
}

func (x CursorType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CursorType) Descriptor() protoreflect.EnumDescriptor {
	return file_datapower_noesis_v1_connector_proto_enumTypes[3].Descriptor()
}

func (CursorType) Type() protoreflect.EnumType {
	return &file_datapower_noesis_v1_connector_proto_enumTypes[3]
}

func (x CursorType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CursorType.Descriptor instead.
func (CursorType) EnumDescriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{3}
}

type Op int32

const (
	Op_OP_UNSPECIFIED Op = 0
	Op_UPSERT         Op = 1
	Op_DELETE         Op = 2
)

// Enum value maps for Op.
var (
	Op_name = map[int32]string{
		0: "OP_UNSPECIFIED",
		1: "UPSERT",
		2: "DELETE",
	}
	Op_value = map[string]int32{
		"OP_UNSPECIFIED": 0,
		"UPSERT":         1,
		"DELETE":         2,
	}
)

func (x Op) Enum() *Op {
	p := new(Op)
	*p = x
	return p
}

func (x Op) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Op) Descriptor() protoreflect.EnumDescriptor {
	return file_datapower_noesis_v1_connector_proto_enumTypes[4].Descriptor()
}

func (Op) Type() protoreflect.EnumType {
	return &file_datapower_noesis_v1_connector_proto_enumTypes[4]
}

func (x Op) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Op.Descriptor instead.
func (Op) EnumDescriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{4}
}

// Null marker
type NullValue int32

const (
	NullValue_NULL_VALUE NullValue = 0
)

// Enum value maps for NullValue.
var (
	NullValue_name = map[int32]string{
		0: "NULL_VALUE",
	}
	NullValue_value = map[string]int32{
		"NULL_VALUE": 0,
	}
)

func (x NullValue) Enum() *NullValue {
	p := new(NullValue)
	*p = x
	return p
}

func (x NullValue) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NullValue) Descriptor() protoreflect.EnumDescriptor {
	return file_datapower_noesis_v1_connector_proto_enumTypes[5].Descriptor()
}

func (NullValue) Type() protoreflect.EnumType {
	return &file_datapower_noesis_v1_connector_proto_enumTypes[5]
}

func (x NullValue) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NullValue.Descriptor instead.
func (NullValue) EnumDescriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{5}
}

type Direction int32

const (
	Direction_DIR_UNSPECIFIED Direction = 0
	Direction_ASC             Direction = 1
	Direction_DESC            Direction = 2
)

// Enum value maps for Direction.
var (
	Direction_name = map[int32]string{
		0: "DIR_UNSPECIFIED",
		1: "ASC",
		2: "DESC",
	}
	Direction_value = map[string]int32{
		"DIR_UNSPECIFIED": 0,
		"ASC":             1,
		"DESC":            2,
	}
)

func (x Direction) Enum() *Direction {
	p := new(Direction)
	*p = x
	return p
}

func (x Direction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Direction) Descriptor() protoreflect.EnumDescriptor {
	return file_datapower_noesis_v1_connector_proto_enumTypes[6].Descriptor()
}

func (Direction) Type() protoreflect.EnumType {
	return &file_datapower_noesis_v1_connector_proto_enumTypes[6]
}

func (x Direction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Direction.Descriptor instead.
func (Direction) EnumDescriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{6}
}

type ConsistencyMode int32

const (
	ConsistencyMode_CONSISTENCY_UNSPECIFIED ConsistencyMode = 0
	ConsistencyMode_READ_COMMITTED          ConsistencyMode = 1
	ConsistencyMode_REPEATABLE_READ         ConsistencyMode = 2
	ConsistencyMode_SNAPSHOT_AS_OF          ConsistencyMode = 3 // Point-in-time ("AS OF") if supported
)

// Enum value maps for ConsistencyMode.
var (
	ConsistencyMode_name = map[int32]string{
		0: "CONSISTENCY_UNSPECIFIED",
		1: "READ_COMMITTED",
		2: "REPEATABLE_READ",
		3: "SNAPSHOT_AS_OF",
	}
	ConsistencyMode_value = map[string]int32{
		"CONSISTENCY_UNSPECIFIED": 0,
		"READ_COMMITTED":          1,
		"REPEATABLE_READ":         2,
		"SNAPSHOT_AS_OF":          3,
	}
)

func (x ConsistencyMode) Enum() *ConsistencyMode {
	p := new(ConsistencyMode)
	*p = x
	return p
}

func (x ConsistencyMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ConsistencyMode) Descriptor() protoreflect.EnumDescriptor {
	return file_datapower_noesis_v1_connector_proto_enumTypes[7].Descriptor()
}

func (ConsistencyMode) Type() protoreflect.EnumType {
	return &file_datapower_noesis_v1_connector_proto_enumTypes[7]
}

func (x ConsistencyMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ConsistencyMode.Descriptor instead.
func (ConsistencyMode) EnumDescriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{7}
}

type TraversalDirection int32

const (
	TraversalDirection_TRAV_DIR_UNSPECIFIED TraversalDirection = 0
	TraversalDirection_OUTBOUND             TraversalDirection = 1
	TraversalDirection_INBOUND              TraversalDirection = 2
	TraversalDirection_BOTH                 TraversalDirection = 3
)

// Enum value maps for TraversalDirection.
var (
	TraversalDirection_name = map[int32]string{
		0: "TRAV_DIR_UNSPECIFIED",
		1: "OUTBOUND",
		2: "INBOUND",
		3: "BOTH",
	}
	TraversalDirection_value = map[string]int32{
		"TRAV_DIR_UNSPECIFIED": 0,
		"OUTBOUND":             1,
		"INBOUND":              2,
		"BOTH":                 3,
	}
)

func (x TraversalDirection) Enum() *TraversalDirection {
	p := new(TraversalDirection)
	*p = x
	return p
}

func (x TraversalDirection) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TraversalDirection) Descriptor() protoreflect.EnumDescriptor {
	return file_datapower_noesis_v1_connector_proto_enumTypes[8].Descriptor()
}

func (TraversalDirection) Type() protoreflect.EnumType {
	return &file_datapower_noesis_v1_connector_proto_enumTypes[8]
}

func (x TraversalDirection) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TraversalDirection.Descriptor instead.
func (TraversalDirection) EnumDescriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{8}
}

type DiscoverRequest struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	TenantId       string                 `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`                    // For multi-tenant scoping and audit.
	EntityFilter   []string               `protobuf:"bytes,2,rep,name=entity_filter,json=entityFilter,proto3" json:"entity_filter,omitempty"`        // Optional: restrict discovery to these entity names.
	IncludeSchemas bool                   `protobuf:"varint,3,opt,name=include_schemas,json=includeSchemas,proto3" json:"include_schemas,omitempty"` // If false, only metadata is returned (no schema payloads).
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *DiscoverRequest) Reset() {
	*x = DiscoverRequest{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiscoverRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiscoverRequest) ProtoMessage() {}

func (x *DiscoverRequest) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiscoverRequest.ProtoReflect.Descriptor instead.
func (*DiscoverRequest) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{0}
}

func (x *DiscoverRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *DiscoverRequest) GetEntityFilter() []string {
	if x != nil {
		return x.EntityFilter
	}
	return nil
}

func (x *DiscoverRequest) GetIncludeSchemas() bool {
	if x != nil {
		return x.IncludeSchemas
	}
	return false
}

type DiscoverResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Platform      *PlatformInfo          `protobuf:"bytes,1,opt,name=platform,proto3" json:"platform,omitempty"` // High-level platform/source info.
	Entities      []*EntityDescriptor    `protobuf:"bytes,2,rep,name=entities,proto3" json:"entities,omitempty"` // All entities (tables/objects and link-objects).
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DiscoverResponse) Reset() {
	*x = DiscoverResponse{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiscoverResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiscoverResponse) ProtoMessage() {}

func (x *DiscoverResponse) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiscoverResponse.ProtoReflect.Descriptor instead.
func (*DiscoverResponse) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{1}
}

func (x *DiscoverResponse) GetPlatform() *PlatformInfo {
	if x != nil {
		return x.Platform
	}
	return nil
}

func (x *DiscoverResponse) GetEntities() []*EntityDescriptor {
	if x != nil {
		return x.Entities
	}
	return nil
}

// Platform/source information (useful for logging, governance, and routing).
type PlatformInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                                                                           // e.g., "Windchill", "Teamcenter", "PostgreSQL"
	Vendor        string                 `protobuf:"bytes,2,opt,name=vendor,proto3" json:"vendor,omitempty"`                                                                       // e.g., "PTC", "Siemens", "PostgreSQL Global Dev"
	Version       string                 `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`                                                                     // e.g., "12.3"
	Timezone      string                 `protobuf:"bytes,4,opt,name=timezone,proto3" json:"timezone,omitempty"`                                                                   // e.g., "UTC"
	Tags          map[string]string      `protobuf:"bytes,5,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Free-form: edition, api_tier, region, etc.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PlatformInfo) Reset() {
	*x = PlatformInfo{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlatformInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlatformInfo) ProtoMessage() {}

func (x *PlatformInfo) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlatformInfo.ProtoReflect.Descriptor instead.
func (*PlatformInfo) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{2}
}

func (x *PlatformInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PlatformInfo) GetVendor() string {
	if x != nil {
		return x.Vendor
	}
	return ""
}

func (x *PlatformInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *PlatformInfo) GetTimezone() string {
	if x != nil {
		return x.Timezone
	}
	return ""
}

func (x *PlatformInfo) GetTags() map[string]string {
	if x != nil {
		return x.Tags
	}
	return nil
}

// An entity is either a business object (NODE) or a link object (LINK) with attributes.
// LINKs must declare their src/dst endpoints (logical FKs).
type EntityDescriptor struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	Name        string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                                      // e.g., "Part", "Document", "BOMLink"
	Kind        EntityKind             `protobuf:"varint,2,opt,name=kind,proto3,enum=datapower.noesis.v1.EntityKind" json:"kind,omitempty"` // NODE or LINK
	DisplayName string                 `protobuf:"bytes,3,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`     // Human-friendly label
	Description string                 `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`                        // Optional docs
	// Schema in structured format
	Schema *StructuredSchemaDescriptor `protobuf:"bytes,5,opt,name=schema,proto3" json:"schema,omitempty"`
	// Keys & relational hints.
	PrimaryKey      []string     `protobuf:"bytes,6,rep,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`                  // ["id"] or a composite key
	UniqueKeys      []*UniqueKey `protobuf:"bytes,7,rep,name=unique_keys,json=uniqueKeys,proto3" json:"unique_keys,omitempty"`                  // Additional unique constraints
	SoftDelete      bool         `protobuf:"varint,8,opt,name=soft_delete,json=softDelete,proto3" json:"soft_delete,omitempty"`                 // If soft deletes exist
	SoftDeleteField string       `protobuf:"bytes,9,opt,name=soft_delete_field,json=softDeleteField,proto3" json:"soft_delete_field,omitempty"` // Field name for soft delete marker (e.g., "deleted_at")
	// For LINK (kind=LINK): logical endpoints the link connects (should match target entity PKs).
	Src *LinkEndpoint `protobuf:"bytes,10,opt,name=src,proto3" json:"src,omitempty"` // Can be empty for NODEs
	Dst *LinkEndpoint `protobuf:"bytes,11,opt,name=dst,proto3" json:"dst,omitempty"`
	// Supported cursor fields for incremental reads (updated_at, version, LSN, etc.).
	Cursors []*CursorField `protobuf:"bytes,12,rep,name=cursors,proto3" json:"cursors,omitempty"`
	// Which extraction modes / features are supported by this entity.
	Capabilities *ExtractionCapabilities `protobuf:"bytes,13,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	// Optional sizing hint.
	EstimatedRows int64 `protobuf:"varint,14,opt,name=estimated_rows,json=estimatedRows,proto3" json:"estimated_rows,omitempty"` // Rough estimate if known, otherwise 0
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EntityDescriptor) Reset() {
	*x = EntityDescriptor{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EntityDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EntityDescriptor) ProtoMessage() {}

func (x *EntityDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EntityDescriptor.ProtoReflect.Descriptor instead.
func (*EntityDescriptor) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{3}
}

func (x *EntityDescriptor) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *EntityDescriptor) GetKind() EntityKind {
	if x != nil {
		return x.Kind
	}
	return EntityKind_KIND_UNSPECIFIED
}

func (x *EntityDescriptor) GetDisplayName() string {
	if x != nil {
		return x.DisplayName
	}
	return ""
}

func (x *EntityDescriptor) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *EntityDescriptor) GetSchema() *StructuredSchemaDescriptor {
	if x != nil {
		return x.Schema
	}
	return nil
}

func (x *EntityDescriptor) GetPrimaryKey() []string {
	if x != nil {
		return x.PrimaryKey
	}
	return nil
}

func (x *EntityDescriptor) GetUniqueKeys() []*UniqueKey {
	if x != nil {
		return x.UniqueKeys
	}
	return nil
}

func (x *EntityDescriptor) GetSoftDelete() bool {
	if x != nil {
		return x.SoftDelete
	}
	return false
}

func (x *EntityDescriptor) GetSoftDeleteField() string {
	if x != nil {
		return x.SoftDeleteField
	}
	return ""
}

func (x *EntityDescriptor) GetSrc() *LinkEndpoint {
	if x != nil {
		return x.Src
	}
	return nil
}

func (x *EntityDescriptor) GetDst() *LinkEndpoint {
	if x != nil {
		return x.Dst
	}
	return nil
}

func (x *EntityDescriptor) GetCursors() []*CursorField {
	if x != nil {
		return x.Cursors
	}
	return nil
}

func (x *EntityDescriptor) GetCapabilities() *ExtractionCapabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *EntityDescriptor) GetEstimatedRows() int64 {
	if x != nil {
		return x.EstimatedRows
	}
	return 0
}

// Individual field/column descriptor
type FieldDescriptor struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                                     // Field name
	Type          FieldType              `protobuf:"varint,2,opt,name=type,proto3,enum=datapower.noesis.v1.FieldType" json:"type,omitempty"` // Field type
	Nullable      bool                   `protobuf:"varint,3,opt,name=nullable,proto3" json:"nullable,omitempty"`                            // Whether field can be NULL
	DefaultValue  string                 `protobuf:"bytes,4,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"` // Default value as string
	Documentation string                 `protobuf:"bytes,5,opt,name=documentation,proto3" json:"documentation,omitempty"`                   // Field documentation/comment
	// Type-specific attributes
	MaxLength        int32     `protobuf:"varint,6,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`                                                            // For STRING/VARCHAR types
	Precision        int32     `protobuf:"varint,7,opt,name=precision,proto3" json:"precision,omitempty"`                                                                             // For DECIMAL types
	Scale            int32     `protobuf:"varint,8,opt,name=scale,proto3" json:"scale,omitempty"`                                                                                     // For DECIMAL types
	EnumValues       []string  `protobuf:"bytes,9,rep,name=enum_values,json=enumValues,proto3" json:"enum_values,omitempty"`                                                          // For ENUM types
	ArrayElementType FieldType `protobuf:"varint,10,opt,name=array_element_type,json=arrayElementType,proto3,enum=datapower.noesis.v1.FieldType" json:"array_element_type,omitempty"` // For ARRAY types
	// Position and ordering
	OrdinalPosition int32 `protobuf:"varint,11,opt,name=ordinal_position,json=ordinalPosition,proto3" json:"ordinal_position,omitempty"` // Position in table
	// Metadata
	Attributes    map[string]string `protobuf:"bytes,12,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Connector-specific attributes
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FieldDescriptor) Reset() {
	*x = FieldDescriptor{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FieldDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FieldDescriptor) ProtoMessage() {}

func (x *FieldDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FieldDescriptor.ProtoReflect.Descriptor instead.
func (*FieldDescriptor) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{4}
}

func (x *FieldDescriptor) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *FieldDescriptor) GetType() FieldType {
	if x != nil {
		return x.Type
	}
	return FieldType_FIELD_TYPE_UNSPECIFIED
}

func (x *FieldDescriptor) GetNullable() bool {
	if x != nil {
		return x.Nullable
	}
	return false
}

func (x *FieldDescriptor) GetDefaultValue() string {
	if x != nil {
		return x.DefaultValue
	}
	return ""
}

func (x *FieldDescriptor) GetDocumentation() string {
	if x != nil {
		return x.Documentation
	}
	return ""
}

func (x *FieldDescriptor) GetMaxLength() int32 {
	if x != nil {
		return x.MaxLength
	}
	return 0
}

func (x *FieldDescriptor) GetPrecision() int32 {
	if x != nil {
		return x.Precision
	}
	return 0
}

func (x *FieldDescriptor) GetScale() int32 {
	if x != nil {
		return x.Scale
	}
	return 0
}

func (x *FieldDescriptor) GetEnumValues() []string {
	if x != nil {
		return x.EnumValues
	}
	return nil
}

func (x *FieldDescriptor) GetArrayElementType() FieldType {
	if x != nil {
		return x.ArrayElementType
	}
	return FieldType_FIELD_TYPE_UNSPECIFIED
}

func (x *FieldDescriptor) GetOrdinalPosition() int32 {
	if x != nil {
		return x.OrdinalPosition
	}
	return 0
}

func (x *FieldDescriptor) GetAttributes() map[string]string {
	if x != nil {
		return x.Attributes
	}
	return nil
}

// Constraint descriptor
type ConstraintDescriptor struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Name    string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                                          // Constraint name
	Type    ConstraintType         `protobuf:"varint,2,opt,name=type,proto3,enum=datapower.noesis.v1.ConstraintType" json:"type,omitempty"` // Constraint type
	Columns []string               `protobuf:"bytes,3,rep,name=columns,proto3" json:"columns,omitempty"`                                    // Columns involved
	// Foreign key specific
	ReferencedTable   string   `protobuf:"bytes,4,opt,name=referenced_table,json=referencedTable,proto3" json:"referenced_table,omitempty"`       // For FK constraints
	ReferencedColumns []string `protobuf:"bytes,5,rep,name=referenced_columns,json=referencedColumns,proto3" json:"referenced_columns,omitempty"` // For FK constraints
	OnDelete          string   `protobuf:"bytes,6,opt,name=on_delete,json=onDelete,proto3" json:"on_delete,omitempty"`                            // CASCADE, SET NULL, etc.
	OnUpdate          string   `protobuf:"bytes,7,opt,name=on_update,json=onUpdate,proto3" json:"on_update,omitempty"`                            // CASCADE, SET NULL, etc.
	// Check constraint specific
	CheckExpression string `protobuf:"bytes,8,opt,name=check_expression,json=checkExpression,proto3" json:"check_expression,omitempty"` // For CHECK constraints
	// Metadata
	Documentation string            `protobuf:"bytes,9,opt,name=documentation,proto3" json:"documentation,omitempty"`                                                                      // Constraint documentation
	Attributes    map[string]string `protobuf:"bytes,10,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Connector-specific attributes
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConstraintDescriptor) Reset() {
	*x = ConstraintDescriptor{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConstraintDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConstraintDescriptor) ProtoMessage() {}

func (x *ConstraintDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConstraintDescriptor.ProtoReflect.Descriptor instead.
func (*ConstraintDescriptor) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{5}
}

func (x *ConstraintDescriptor) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ConstraintDescriptor) GetType() ConstraintType {
	if x != nil {
		return x.Type
	}
	return ConstraintType_CONSTRAINT_TYPE_UNSPECIFIED
}

func (x *ConstraintDescriptor) GetColumns() []string {
	if x != nil {
		return x.Columns
	}
	return nil
}

func (x *ConstraintDescriptor) GetReferencedTable() string {
	if x != nil {
		return x.ReferencedTable
	}
	return ""
}

func (x *ConstraintDescriptor) GetReferencedColumns() []string {
	if x != nil {
		return x.ReferencedColumns
	}
	return nil
}

func (x *ConstraintDescriptor) GetOnDelete() string {
	if x != nil {
		return x.OnDelete
	}
	return ""
}

func (x *ConstraintDescriptor) GetOnUpdate() string {
	if x != nil {
		return x.OnUpdate
	}
	return ""
}

func (x *ConstraintDescriptor) GetCheckExpression() string {
	if x != nil {
		return x.CheckExpression
	}
	return ""
}

func (x *ConstraintDescriptor) GetDocumentation() string {
	if x != nil {
		return x.Documentation
	}
	return ""
}

func (x *ConstraintDescriptor) GetAttributes() map[string]string {
	if x != nil {
		return x.Attributes
	}
	return nil
}

// Index descriptor
type IndexDescriptor struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`                                                                                       // Index name
	Columns       []string               `protobuf:"bytes,2,rep,name=columns,proto3" json:"columns,omitempty"`                                                                                 // Indexed columns
	Unique        bool                   `protobuf:"varint,3,opt,name=unique,proto3" json:"unique,omitempty"`                                                                                  // Whether index is unique
	Type          string                 `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`                                                                                       // BTREE, HASH, GIN, etc.
	Condition     string                 `protobuf:"bytes,5,opt,name=condition,proto3" json:"condition,omitempty"`                                                                             // Partial index condition
	Documentation string                 `protobuf:"bytes,6,opt,name=documentation,proto3" json:"documentation,omitempty"`                                                                     // Index documentation
	Attributes    map[string]string      `protobuf:"bytes,7,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Connector-specific attributes
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IndexDescriptor) Reset() {
	*x = IndexDescriptor{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IndexDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndexDescriptor) ProtoMessage() {}

func (x *IndexDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndexDescriptor.ProtoReflect.Descriptor instead.
func (*IndexDescriptor) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{6}
}

func (x *IndexDescriptor) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *IndexDescriptor) GetColumns() []string {
	if x != nil {
		return x.Columns
	}
	return nil
}

func (x *IndexDescriptor) GetUnique() bool {
	if x != nil {
		return x.Unique
	}
	return false
}

func (x *IndexDescriptor) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *IndexDescriptor) GetCondition() string {
	if x != nil {
		return x.Condition
	}
	return ""
}

func (x *IndexDescriptor) GetDocumentation() string {
	if x != nil {
		return x.Documentation
	}
	return ""
}

func (x *IndexDescriptor) GetAttributes() map[string]string {
	if x != nil {
		return x.Attributes
	}
	return nil
}

// Enhanced schema descriptor with structured fields
type StructuredSchemaDescriptor struct {
	state         protoimpl.MessageState  `protogen:"open.v1"`
	SchemaId      string                  `protobuf:"bytes,1,opt,name=schema_id,json=schemaId,proto3" json:"schema_id,omitempty"`                                                               // Schema version identifier
	Fields        []*FieldDescriptor      `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty"`                                                                                   // Field definitions
	Constraints   []*ConstraintDescriptor `protobuf:"bytes,3,rep,name=constraints,proto3" json:"constraints,omitempty"`                                                                         // Constraints
	Indexes       []*IndexDescriptor      `protobuf:"bytes,4,rep,name=indexes,proto3" json:"indexes,omitempty"`                                                                                 // Indexes
	Attributes    map[string]string       `protobuf:"bytes,5,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Table-level attributes
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StructuredSchemaDescriptor) Reset() {
	*x = StructuredSchemaDescriptor{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StructuredSchemaDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StructuredSchemaDescriptor) ProtoMessage() {}

func (x *StructuredSchemaDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StructuredSchemaDescriptor.ProtoReflect.Descriptor instead.
func (*StructuredSchemaDescriptor) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{7}
}

func (x *StructuredSchemaDescriptor) GetSchemaId() string {
	if x != nil {
		return x.SchemaId
	}
	return ""
}

func (x *StructuredSchemaDescriptor) GetFields() []*FieldDescriptor {
	if x != nil {
		return x.Fields
	}
	return nil
}

func (x *StructuredSchemaDescriptor) GetConstraints() []*ConstraintDescriptor {
	if x != nil {
		return x.Constraints
	}
	return nil
}

func (x *StructuredSchemaDescriptor) GetIndexes() []*IndexDescriptor {
	if x != nil {
		return x.Indexes
	}
	return nil
}

func (x *StructuredSchemaDescriptor) GetAttributes() map[string]string {
	if x != nil {
		return x.Attributes
	}
	return nil
}

type UniqueKey struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Columns       []string               `protobuf:"bytes,1,rep,name=columns,proto3" json:"columns,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UniqueKey) Reset() {
	*x = UniqueKey{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UniqueKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UniqueKey) ProtoMessage() {}

func (x *UniqueKey) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UniqueKey.ProtoReflect.Descriptor instead.
func (*UniqueKey) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{8}
}

func (x *UniqueKey) GetColumns() []string {
	if x != nil {
		return x.Columns
	}
	return nil
}

type LinkEndpoint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Entity        string                 `protobuf:"bytes,1,opt,name=entity,proto3" json:"entity,omitempty"`                        // Target entity name, e.g., "Part"
	KeyFields     []string               `protobuf:"bytes,2,rep,name=key_fields,json=keyFields,proto3" json:"key_fields,omitempty"` // Fields in THIS entity that reference the target PK (order must match PK)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LinkEndpoint) Reset() {
	*x = LinkEndpoint{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LinkEndpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LinkEndpoint) ProtoMessage() {}

func (x *LinkEndpoint) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LinkEndpoint.ProtoReflect.Descriptor instead.
func (*LinkEndpoint) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{9}
}

func (x *LinkEndpoint) GetEntity() string {
	if x != nil {
		return x.Entity
	}
	return ""
}

func (x *LinkEndpoint) GetKeyFields() []string {
	if x != nil {
		return x.KeyFields
	}
	return nil
}

type CursorField struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Field         string                 `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"` // e.g., "updated_at", "version", "lsn"
	Type          CursorType             `protobuf:"varint,2,opt,name=type,proto3,enum=datapower.noesis.v1.CursorType" json:"type,omitempty"`
	Monotonic     bool                   `protobuf:"varint,3,opt,name=monotonic,proto3" json:"monotonic,omitempty"` // True if non-decreasing is guaranteed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CursorField) Reset() {
	*x = CursorField{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CursorField) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CursorField) ProtoMessage() {}

func (x *CursorField) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CursorField.ProtoReflect.Descriptor instead.
func (*CursorField) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{10}
}

func (x *CursorField) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *CursorField) GetType() CursorType {
	if x != nil {
		return x.Type
	}
	return CursorType_CURSOR_TYPE_UNSPECIFIED
}

func (x *CursorField) GetMonotonic() bool {
	if x != nil {
		return x.Monotonic
	}
	return false
}

// Per-entity capabilities (what this connector can do for that entity).
type ExtractionCapabilities struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// High-level modes
	SupportsFullTable    bool `protobuf:"varint,1,opt,name=supports_full_table,json=supportsFullTable,proto3" json:"supports_full_table,omitempty"`
	SupportsChangeStream bool `protobuf:"varint,2,opt,name=supports_change_stream,json=supportsChangeStream,proto3" json:"supports_change_stream,omitempty"`
	SupportsSubgraph     bool `protobuf:"varint,3,opt,name=supports_subgraph,json=supportsSubgraph,proto3" json:"supports_subgraph,omitempty"` // Typically meaningful for NODEs involved in LINKs
	// Query features
	SupportsProjection bool     `protobuf:"varint,10,opt,name=supports_projection,json=supportsProjection,proto3" json:"supports_projection,omitempty"` // Select subset of columns
	SupportsFilter     bool     `protobuf:"varint,11,opt,name=supports_filter,json=supportsFilter,proto3" json:"supports_filter,omitempty"`             // Server-side filtering
	SupportsOrdering   bool     `protobuf:"varint,12,opt,name=supports_ordering,json=supportsOrdering,proto3" json:"supports_ordering,omitempty"`       // Stable ORDER BY on given columns
	OrderableFields    []string `protobuf:"bytes,13,rep,name=orderable_fields,json=orderableFields,proto3" json:"orderable_fields,omitempty"`           // Fields that can be used for stable ordering (e.g., PK columns)
	// Subgraph specifics (only relevant if supports_subgraph=true)
	SubgraphLinkEntities      []string `protobuf:"bytes,20,rep,name=subgraph_link_entities,json=subgraphLinkEntities,proto3" json:"subgraph_link_entities,omitempty"`                   // LINK entity names allowed during traversal
	SubgraphMaxDepthSupported int32    `protobuf:"varint,21,opt,name=subgraph_max_depth_supported,json=subgraphMaxDepthSupported,proto3" json:"subgraph_max_depth_supported,omitempty"` // -1 = unlimited; 0 = head only; N = max depth
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *ExtractionCapabilities) Reset() {
	*x = ExtractionCapabilities{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExtractionCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExtractionCapabilities) ProtoMessage() {}

func (x *ExtractionCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExtractionCapabilities.ProtoReflect.Descriptor instead.
func (*ExtractionCapabilities) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{11}
}

func (x *ExtractionCapabilities) GetSupportsFullTable() bool {
	if x != nil {
		return x.SupportsFullTable
	}
	return false
}

func (x *ExtractionCapabilities) GetSupportsChangeStream() bool {
	if x != nil {
		return x.SupportsChangeStream
	}
	return false
}

func (x *ExtractionCapabilities) GetSupportsSubgraph() bool {
	if x != nil {
		return x.SupportsSubgraph
	}
	return false
}

func (x *ExtractionCapabilities) GetSupportsProjection() bool {
	if x != nil {
		return x.SupportsProjection
	}
	return false
}

func (x *ExtractionCapabilities) GetSupportsFilter() bool {
	if x != nil {
		return x.SupportsFilter
	}
	return false
}

func (x *ExtractionCapabilities) GetSupportsOrdering() bool {
	if x != nil {
		return x.SupportsOrdering
	}
	return false
}

func (x *ExtractionCapabilities) GetOrderableFields() []string {
	if x != nil {
		return x.OrderableFields
	}
	return nil
}

func (x *ExtractionCapabilities) GetSubgraphLinkEntities() []string {
	if x != nil {
		return x.SubgraphLinkEntities
	}
	return nil
}

func (x *ExtractionCapabilities) GetSubgraphMaxDepthSupported() int32 {
	if x != nil {
		return x.SubgraphMaxDepthSupported
	}
	return 0
}

// ===========================
//
//	CHECK / OPEN / CLOSE
//
// ===========================
type CheckRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TenantId      string                 `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	Config        map[string]string      `protobuf:"bytes,2,rep,name=config,proto3" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Source credentials, endpoints, options
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckRequest) Reset() {
	*x = CheckRequest{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckRequest) ProtoMessage() {}

func (x *CheckRequest) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckRequest.ProtoReflect.Descriptor instead.
func (*CheckRequest) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{12}
}

func (x *CheckRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *CheckRequest) GetConfig() map[string]string {
	if x != nil {
		return x.Config
	}
	return nil
}

type CheckResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ok            bool                   `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`                                                                           // When not ok: reason
	Details       map[string]string      `protobuf:"bytes,3,rep,name=details,proto3" json:"details,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Optional more info
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckResponse) Reset() {
	*x = CheckResponse{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckResponse) ProtoMessage() {}

func (x *CheckResponse) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckResponse.ProtoReflect.Descriptor instead.
func (*CheckResponse) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{13}
}

func (x *CheckResponse) GetOk() bool {
	if x != nil {
		return x.Ok
	}
	return false
}

func (x *CheckResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *CheckResponse) GetDetails() map[string]string {
	if x != nil {
		return x.Details
	}
	return nil
}

type OpenRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TenantId      string                 `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	Config        map[string]string      `protobuf:"bytes,2,rep,name=config,proto3" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Same config used for Read; connector may pin snapshot here
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OpenRequest) Reset() {
	*x = OpenRequest{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpenRequest) ProtoMessage() {}

func (x *OpenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpenRequest.ProtoReflect.Descriptor instead.
func (*OpenRequest) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{14}
}

func (x *OpenRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *OpenRequest) GetConfig() map[string]string {
	if x != nil {
		return x.Config
	}
	return nil
}

type OpenResponse struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	SessionId        string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`                           // Optional logical session id (echo back in logs)
	ExpiresAtEpochMs int64                  `protobuf:"varint,2,opt,name=expires_at_epoch_ms,json=expiresAtEpochMs,proto3" json:"expires_at_epoch_ms,omitempty"` // Optional: when the session should be considered stale
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *OpenResponse) Reset() {
	*x = OpenResponse{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpenResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpenResponse) ProtoMessage() {}

func (x *OpenResponse) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpenResponse.ProtoReflect.Descriptor instead.
func (*OpenResponse) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{15}
}

func (x *OpenResponse) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *OpenResponse) GetExpiresAtEpochMs() int64 {
	if x != nil {
		return x.ExpiresAtEpochMs
	}
	return 0
}

type CloseRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CloseRequest) Reset() {
	*x = CloseRequest{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CloseRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloseRequest) ProtoMessage() {}

func (x *CloseRequest) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloseRequest.ProtoReflect.Descriptor instead.
func (*CloseRequest) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{16}
}

func (x *CloseRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

type CloseResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CloseResponse) Reset() {
	*x = CloseResponse{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CloseResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloseResponse) ProtoMessage() {}

func (x *CloseResponse) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloseResponse.ProtoReflect.Descriptor instead.
func (*CloseResponse) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{17}
}

// Plan parallel extraction for a batch source entity.
// The connector analyzes the entity and returns N independent splits
// that can be extracted in parallel for optimal throughput.
type PlanExtractionRequest struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	TenantId           string                 `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`                                                       // For multi-tenant scoping
	Entity             string                 `protobuf:"bytes,2,opt,name=entity,proto3" json:"entity,omitempty"`                                                                           // Entity to extract (e.g., "customers")
	DesiredParallelism int32                  `protobuf:"varint,3,opt,name=desired_parallelism,json=desiredParallelism,proto3" json:"desired_parallelism,omitempty"`                        // Hint: how many splits to generate (connector may adjust)
	Config             map[string]string      `protobuf:"bytes,4,rep,name=config,proto3" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Source connection configuration
	Filter             *Filter                `protobuf:"bytes,5,opt,name=filter,proto3" json:"filter,omitempty"`                                                                           // Optional: global filter to apply to all splits
	Snapshot           *SnapshotOptions       `protobuf:"bytes,6,opt,name=snapshot,proto3" json:"snapshot,omitempty"`                                                                       // Consistency requirements
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *PlanExtractionRequest) Reset() {
	*x = PlanExtractionRequest{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlanExtractionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlanExtractionRequest) ProtoMessage() {}

func (x *PlanExtractionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlanExtractionRequest.ProtoReflect.Descriptor instead.
func (*PlanExtractionRequest) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{18}
}

func (x *PlanExtractionRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *PlanExtractionRequest) GetEntity() string {
	if x != nil {
		return x.Entity
	}
	return ""
}

func (x *PlanExtractionRequest) GetDesiredParallelism() int32 {
	if x != nil {
		return x.DesiredParallelism
	}
	return 0
}

func (x *PlanExtractionRequest) GetConfig() map[string]string {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *PlanExtractionRequest) GetFilter() *Filter {
	if x != nil {
		return x.Filter
	}
	return nil
}

func (x *PlanExtractionRequest) GetSnapshot() *SnapshotOptions {
	if x != nil {
		return x.Snapshot
	}
	return nil
}

type PlanExtractionResponse struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Splits             []*ExtractionSplit     `protobuf:"bytes,1,rep,name=splits,proto3" json:"splits,omitempty"`                                                      // List of independent extraction splits
	SnapshotId         string                 `protobuf:"bytes,2,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`                            // Optional: snapshot identifier for consistency
	TotalEstimatedRows int64                  `protobuf:"varint,3,opt,name=total_estimated_rows,json=totalEstimatedRows,proto3" json:"total_estimated_rows,omitempty"` // Total estimated rows across all splits
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *PlanExtractionResponse) Reset() {
	*x = PlanExtractionResponse{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PlanExtractionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlanExtractionResponse) ProtoMessage() {}

func (x *PlanExtractionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlanExtractionResponse.ProtoReflect.Descriptor instead.
func (*PlanExtractionResponse) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{19}
}

func (x *PlanExtractionResponse) GetSplits() []*ExtractionSplit {
	if x != nil {
		return x.Splits
	}
	return nil
}

func (x *PlanExtractionResponse) GetSnapshotId() string {
	if x != nil {
		return x.SnapshotId
	}
	return ""
}

func (x *PlanExtractionResponse) GetTotalEstimatedRows() int64 {
	if x != nil {
		return x.TotalEstimatedRows
	}
	return 0
}

// Represents an independent unit of work for parallel extraction.
// The split token is opaque and connector-specific (could encode key ranges,
// partition IDs, file paths, etc.)
type ExtractionSplit struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SplitId       string                 `protobuf:"bytes,1,opt,name=split_id,json=splitId,proto3" json:"split_id,omitempty"`                                                              // Unique identifier for this split (e.g., "split-0001")
	SplitToken    []byte                 `protobuf:"bytes,2,opt,name=split_token,json=splitToken,proto3" json:"split_token,omitempty"`                                                     // Opaque connector-specific split metadata
	EstimatedRows int64                  `protobuf:"varint,3,opt,name=estimated_rows,json=estimatedRows,proto3" json:"estimated_rows,omitempty"`                                           // Estimated rows in this split (0 if unknown)
	Metadata      map[string]string      `protobuf:"bytes,4,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Optional split metadata (for logging/debugging)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExtractionSplit) Reset() {
	*x = ExtractionSplit{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExtractionSplit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExtractionSplit) ProtoMessage() {}

func (x *ExtractionSplit) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExtractionSplit.ProtoReflect.Descriptor instead.
func (*ExtractionSplit) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{20}
}

func (x *ExtractionSplit) GetSplitId() string {
	if x != nil {
		return x.SplitId
	}
	return ""
}

func (x *ExtractionSplit) GetSplitToken() []byte {
	if x != nil {
		return x.SplitToken
	}
	return nil
}

func (x *ExtractionSplit) GetEstimatedRows() int64 {
	if x != nil {
		return x.EstimatedRows
	}
	return 0
}

func (x *ExtractionSplit) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// Read a specific extraction split (for parallel batch extraction).
type ReadSplitRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TenantId      string                 `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`       // For multi-tenant scoping
	Entity        string                 `protobuf:"bytes,2,opt,name=entity,proto3" json:"entity,omitempty"`                           // Entity being extracted
	Split         *ExtractionSplit       `protobuf:"bytes,3,opt,name=split,proto3" json:"split,omitempty"`                             // The split to read
	SnapshotId    string                 `protobuf:"bytes,4,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"` // Optional: from PlanExtractionResponse
	Projection    *Projection            `protobuf:"bytes,5,opt,name=projection,proto3" json:"projection,omitempty"`                   // Optional: subset of fields
	RateLimit     *RateLimit             `protobuf:"bytes,6,opt,name=rate_limit,json=rateLimit,proto3" json:"rate_limit,omitempty"`    // Optional: QPS/parallelism limits
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadSplitRequest) Reset() {
	*x = ReadSplitRequest{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadSplitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadSplitRequest) ProtoMessage() {}

func (x *ReadSplitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadSplitRequest.ProtoReflect.Descriptor instead.
func (*ReadSplitRequest) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{21}
}

func (x *ReadSplitRequest) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *ReadSplitRequest) GetEntity() string {
	if x != nil {
		return x.Entity
	}
	return ""
}

func (x *ReadSplitRequest) GetSplit() *ExtractionSplit {
	if x != nil {
		return x.Split
	}
	return nil
}

func (x *ReadSplitRequest) GetSnapshotId() string {
	if x != nil {
		return x.SnapshotId
	}
	return ""
}

func (x *ReadSplitRequest) GetProjection() *Projection {
	if x != nil {
		return x.Projection
	}
	return nil
}

func (x *ReadSplitRequest) GetRateLimit() *RateLimit {
	if x != nil {
		return x.RateLimit
	}
	return nil
}

type ReadRequest struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	SessionId string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"` // Optional, if Open/Close are used
	// Exactly one mode must be set:
	//
	// Types that are valid to be assigned to Mode:
	//
	//	*ReadRequest_FullTable
	//	*ReadRequest_ChangeStream
	//	*ReadRequest_Subgraph
	Mode          isReadRequest_Mode `protobuf_oneof:"mode"`
	Projection    *Projection        `protobuf:"bytes,2,opt,name=projection,proto3" json:"projection,omitempty"`                // Optional: subset of fields to return
	RateLimit     *RateLimit         `protobuf:"bytes,3,opt,name=rate_limit,json=rateLimit,proto3" json:"rate_limit,omitempty"` // Optional: QPS/parallelism limits
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadRequest) Reset() {
	*x = ReadRequest{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadRequest) ProtoMessage() {}

func (x *ReadRequest) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadRequest.ProtoReflect.Descriptor instead.
func (*ReadRequest) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{22}
}

func (x *ReadRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *ReadRequest) GetMode() isReadRequest_Mode {
	if x != nil {
		return x.Mode
	}
	return nil
}

func (x *ReadRequest) GetFullTable() *FullTableScan {
	if x != nil {
		if x, ok := x.Mode.(*ReadRequest_FullTable); ok {
			return x.FullTable
		}
	}
	return nil
}

func (x *ReadRequest) GetChangeStream() *ChangeStream {
	if x != nil {
		if x, ok := x.Mode.(*ReadRequest_ChangeStream); ok {
			return x.ChangeStream
		}
	}
	return nil
}

func (x *ReadRequest) GetSubgraph() *SubgraphRead {
	if x != nil {
		if x, ok := x.Mode.(*ReadRequest_Subgraph); ok {
			return x.Subgraph
		}
	}
	return nil
}

func (x *ReadRequest) GetProjection() *Projection {
	if x != nil {
		return x.Projection
	}
	return nil
}

func (x *ReadRequest) GetRateLimit() *RateLimit {
	if x != nil {
		return x.RateLimit
	}
	return nil
}

type isReadRequest_Mode interface {
	isReadRequest_Mode()
}

type ReadRequest_FullTable struct {
	FullTable *FullTableScan `protobuf:"bytes,10,opt,name=full_table,json=fullTable,proto3,oneof"`
}

type ReadRequest_ChangeStream struct {
	ChangeStream *ChangeStream `protobuf:"bytes,11,opt,name=change_stream,json=changeStream,proto3,oneof"`
}

type ReadRequest_Subgraph struct {
	Subgraph *SubgraphRead `protobuf:"bytes,12,opt,name=subgraph,proto3,oneof"`
}

func (*ReadRequest_FullTable) isReadRequest_Mode() {}

func (*ReadRequest_ChangeStream) isReadRequest_Mode() {}

func (*ReadRequest_Subgraph) isReadRequest_Mode() {}

type FullTableScan struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Entity        string                 `protobuf:"bytes,1,opt,name=entity,proto3" json:"entity,omitempty"`                           // Entity name (NODE or LINK)
	ResumeFrom    *Cursor                `protobuf:"bytes,2,opt,name=resume_from,json=resumeFrom,proto3" json:"resume_from,omitempty"` // Opaque cursor for resume (page token, last_pk, etc.)
	Filter        *Filter                `protobuf:"bytes,3,opt,name=filter,proto3" json:"filter,omitempty"`                           // Optional server-side filter
	Ordering      *Ordering              `protobuf:"bytes,4,opt,name=ordering,proto3" json:"ordering,omitempty"`                       // Stable ordering (e.g., primary key asc)
	Snapshot      *SnapshotOptions       `protobuf:"bytes,5,opt,name=snapshot,proto3" json:"snapshot,omitempty"`                       // How to ensure consistency
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FullTableScan) Reset() {
	*x = FullTableScan{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FullTableScan) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FullTableScan) ProtoMessage() {}

func (x *FullTableScan) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FullTableScan.ProtoReflect.Descriptor instead.
func (*FullTableScan) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{23}
}

func (x *FullTableScan) GetEntity() string {
	if x != nil {
		return x.Entity
	}
	return ""
}

func (x *FullTableScan) GetResumeFrom() *Cursor {
	if x != nil {
		return x.ResumeFrom
	}
	return nil
}

func (x *FullTableScan) GetFilter() *Filter {
	if x != nil {
		return x.Filter
	}
	return nil
}

func (x *FullTableScan) GetOrdering() *Ordering {
	if x != nil {
		return x.Ordering
	}
	return nil
}

func (x *FullTableScan) GetSnapshot() *SnapshotOptions {
	if x != nil {
		return x.Snapshot
	}
	return nil
}

type ChangeStream struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Entity        string                 `protobuf:"bytes,1,opt,name=entity,proto3" json:"entity,omitempty"` // Change feed / CDC for this entity
	From          *Cursor                `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`     // Opaque starting position (LSN/offset/timestamp)
	Filter        *Filter                `protobuf:"bytes,3,opt,name=filter,proto3" json:"filter,omitempty"` // Optional filter (e.g., updated_at >= T)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChangeStream) Reset() {
	*x = ChangeStream{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChangeStream) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChangeStream) ProtoMessage() {}

func (x *ChangeStream) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChangeStream.ProtoReflect.Descriptor instead.
func (*ChangeStream) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{24}
}

func (x *ChangeStream) GetEntity() string {
	if x != nil {
		return x.Entity
	}
	return ""
}

func (x *ChangeStream) GetFrom() *Cursor {
	if x != nil {
		return x.From
	}
	return nil
}

func (x *ChangeStream) GetFilter() *Filter {
	if x != nil {
		return x.Filter
	}
	return nil
}

type SubgraphRead struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Heads         []*Head                `protobuf:"bytes,1,rep,name=heads,proto3" json:"heads,omitempty"`                             // Starting nodes (entity/key)
	Traversal     *Traversal             `protobuf:"bytes,2,opt,name=traversal,proto3" json:"traversal,omitempty"`                     // Traversal policy
	Snapshot      *SnapshotOptions       `protobuf:"bytes,3,opt,name=snapshot,proto3" json:"snapshot,omitempty"`                       // Consistent view for nodes+links
	ResumeFrom    *Cursor                `protobuf:"bytes,4,opt,name=resume_from,json=resumeFrom,proto3" json:"resume_from,omitempty"` // Opaque traversal frontier for resume
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubgraphRead) Reset() {
	*x = SubgraphRead{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubgraphRead) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubgraphRead) ProtoMessage() {}

func (x *SubgraphRead) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubgraphRead.ProtoReflect.Descriptor instead.
func (*SubgraphRead) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{25}
}

func (x *SubgraphRead) GetHeads() []*Head {
	if x != nil {
		return x.Heads
	}
	return nil
}

func (x *SubgraphRead) GetTraversal() *Traversal {
	if x != nil {
		return x.Traversal
	}
	return nil
}

func (x *SubgraphRead) GetSnapshot() *SnapshotOptions {
	if x != nil {
		return x.Snapshot
	}
	return nil
}

func (x *SubgraphRead) GetResumeFrom() *Cursor {
	if x != nil {
		return x.ResumeFrom
	}
	return nil
}

type Head struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Entity        string                 `protobuf:"bytes,1,opt,name=entity,proto3" json:"entity,omitempty"`
	Key           string                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Head) Reset() {
	*x = Head{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Head) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Head) ProtoMessage() {}

func (x *Head) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Head.ProtoReflect.Descriptor instead.
func (*Head) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{26}
}

func (x *Head) GetEntity() string {
	if x != nil {
		return x.Entity
	}
	return ""
}

func (x *Head) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

// Stream payload: schema messages (optional), data records (NODE or LINK), periodic state checkpoints,
// plus logs/metrics for observability.
type ReadMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Msg:
	//
	//	*ReadMessage_Schema
	//	*ReadMessage_Record
	//	*ReadMessage_State
	//	*ReadMessage_Log
	//	*ReadMessage_Metric
	Msg           isReadMessage_Msg `protobuf_oneof:"msg"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadMessage) Reset() {
	*x = ReadMessage{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadMessage) ProtoMessage() {}

func (x *ReadMessage) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadMessage.ProtoReflect.Descriptor instead.
func (*ReadMessage) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{27}
}

func (x *ReadMessage) GetMsg() isReadMessage_Msg {
	if x != nil {
		return x.Msg
	}
	return nil
}

func (x *ReadMessage) GetSchema() *SchemaMsg {
	if x != nil {
		if x, ok := x.Msg.(*ReadMessage_Schema); ok {
			return x.Schema
		}
	}
	return nil
}

func (x *ReadMessage) GetRecord() *RecordMsg {
	if x != nil {
		if x, ok := x.Msg.(*ReadMessage_Record); ok {
			return x.Record
		}
	}
	return nil
}

func (x *ReadMessage) GetState() *StateMsg {
	if x != nil {
		if x, ok := x.Msg.(*ReadMessage_State); ok {
			return x.State
		}
	}
	return nil
}

func (x *ReadMessage) GetLog() *LogMsg {
	if x != nil {
		if x, ok := x.Msg.(*ReadMessage_Log); ok {
			return x.Log
		}
	}
	return nil
}

func (x *ReadMessage) GetMetric() *MetricMsg {
	if x != nil {
		if x, ok := x.Msg.(*ReadMessage_Metric); ok {
			return x.Metric
		}
	}
	return nil
}

type isReadMessage_Msg interface {
	isReadMessage_Msg()
}

type ReadMessage_Schema struct {
	Schema *SchemaMsg `protobuf:"bytes,1,opt,name=schema,proto3,oneof"` // (Optional) schema broadcast/update
}

type ReadMessage_Record struct {
	Record *RecordMsg `protobuf:"bytes,2,opt,name=record,proto3,oneof"` // Data (NODE or LINK), including deletes
}

type ReadMessage_State struct {
	State *StateMsg `protobuf:"bytes,3,opt,name=state,proto3,oneof"` // Checkpoint (cursor/watermark/group frontier)
}

type ReadMessage_Log struct {
	Log *LogMsg `protobuf:"bytes,4,opt,name=log,proto3,oneof"` // Structured logs
}

type ReadMessage_Metric struct {
	Metric *MetricMsg `protobuf:"bytes,5,opt,name=metric,proto3,oneof"` // Simple metrics
}

func (*ReadMessage_Schema) isReadMessage_Msg() {}

func (*ReadMessage_Record) isReadMessage_Msg() {}

func (*ReadMessage_State) isReadMessage_Msg() {}

func (*ReadMessage_Log) isReadMessage_Msg() {}

func (*ReadMessage_Metric) isReadMessage_Msg() {}

// Storage-agnostic record representation.
// Simple typed structure that can be written to Parquet, Iceberg, Delta Lake, etc.
type RecordMsg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Entity        string                 `protobuf:"bytes,1,opt,name=entity,proto3" json:"entity,omitempty"`                                 // e.g., "Part" or "BOMLink"
	Data          *Row                   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`                                     // The actual row data (typed columns)
	Op            Op                     `protobuf:"varint,3,opt,name=op,proto3,enum=datapower.noesis.v1.Op" json:"op,omitempty"`            // UPSERT/DELETE
	EventTimeMs   int64                  `protobuf:"varint,4,opt,name=event_time_ms,json=eventTimeMs,proto3" json:"event_time_ms,omitempty"` // Source event timestamp (epoch millis)
	SchemaId      string                 `protobuf:"bytes,5,opt,name=schema_id,json=schemaId,proto3" json:"schema_id,omitempty"`             // Schema version identifier
	GroupId       string                 `protobuf:"bytes,6,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`                // For subgraph: group all records belonging to the same head
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RecordMsg) Reset() {
	*x = RecordMsg{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecordMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecordMsg) ProtoMessage() {}

func (x *RecordMsg) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecordMsg.ProtoReflect.Descriptor instead.
func (*RecordMsg) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{28}
}

func (x *RecordMsg) GetEntity() string {
	if x != nil {
		return x.Entity
	}
	return ""
}

func (x *RecordMsg) GetData() *Row {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *RecordMsg) GetOp() Op {
	if x != nil {
		return x.Op
	}
	return Op_OP_UNSPECIFIED
}

func (x *RecordMsg) GetEventTimeMs() int64 {
	if x != nil {
		return x.EventTimeMs
	}
	return 0
}

func (x *RecordMsg) GetSchemaId() string {
	if x != nil {
		return x.SchemaId
	}
	return ""
}

func (x *RecordMsg) GetGroupId() string {
	if x != nil {
		return x.GroupId
	}
	return ""
}

// Simple row representation - maps directly to storage formats.
// Each column is a named, typed value.
type Row struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Columns       map[string]*Value      `protobuf:"bytes,1,rep,name=columns,proto3" json:"columns,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Column name -> typed value
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Row) Reset() {
	*x = Row{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Row) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Row) ProtoMessage() {}

func (x *Row) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Row.ProtoReflect.Descriptor instead.
func (*Row) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{29}
}

func (x *Row) GetColumns() map[string]*Value {
	if x != nil {
		return x.Columns
	}
	return nil
}

// Typed value supporting common database types.
// Designed to map cleanly to Parquet, Arrow, and SQL types.
type Value struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Kind:
	//
	//	*Value_StringVal
	//	*Value_Int64Val
	//	*Value_Int32Val
	//	*Value_DoubleVal
	//	*Value_FloatVal
	//	*Value_BoolVal
	//	*Value_BytesVal
	//	*Value_TimestampMicros
	//	*Value_DateDays
	//	*Value_TimeMicros
	//	*Value_NullVal
	//	*Value_StructVal
	//	*Value_ListVal
	//	*Value_MapVal
	Kind          isValue_Kind `protobuf_oneof:"kind"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Value) Reset() {
	*x = Value{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Value) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Value) ProtoMessage() {}

func (x *Value) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Value.ProtoReflect.Descriptor instead.
func (*Value) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{30}
}

func (x *Value) GetKind() isValue_Kind {
	if x != nil {
		return x.Kind
	}
	return nil
}

func (x *Value) GetStringVal() string {
	if x != nil {
		if x, ok := x.Kind.(*Value_StringVal); ok {
			return x.StringVal
		}
	}
	return ""
}

func (x *Value) GetInt64Val() int64 {
	if x != nil {
		if x, ok := x.Kind.(*Value_Int64Val); ok {
			return x.Int64Val
		}
	}
	return 0
}

func (x *Value) GetInt32Val() int32 {
	if x != nil {
		if x, ok := x.Kind.(*Value_Int32Val); ok {
			return x.Int32Val
		}
	}
	return 0
}

func (x *Value) GetDoubleVal() float64 {
	if x != nil {
		if x, ok := x.Kind.(*Value_DoubleVal); ok {
			return x.DoubleVal
		}
	}
	return 0
}

func (x *Value) GetFloatVal() float32 {
	if x != nil {
		if x, ok := x.Kind.(*Value_FloatVal); ok {
			return x.FloatVal
		}
	}
	return 0
}

func (x *Value) GetBoolVal() bool {
	if x != nil {
		if x, ok := x.Kind.(*Value_BoolVal); ok {
			return x.BoolVal
		}
	}
	return false
}

func (x *Value) GetBytesVal() []byte {
	if x != nil {
		if x, ok := x.Kind.(*Value_BytesVal); ok {
			return x.BytesVal
		}
	}
	return nil
}

func (x *Value) GetTimestampMicros() int64 {
	if x != nil {
		if x, ok := x.Kind.(*Value_TimestampMicros); ok {
			return x.TimestampMicros
		}
	}
	return 0
}

func (x *Value) GetDateDays() int32 {
	if x != nil {
		if x, ok := x.Kind.(*Value_DateDays); ok {
			return x.DateDays
		}
	}
	return 0
}

func (x *Value) GetTimeMicros() int64 {
	if x != nil {
		if x, ok := x.Kind.(*Value_TimeMicros); ok {
			return x.TimeMicros
		}
	}
	return 0
}

func (x *Value) GetNullVal() NullValue {
	if x != nil {
		if x, ok := x.Kind.(*Value_NullVal); ok {
			return x.NullVal
		}
	}
	return NullValue_NULL_VALUE
}

func (x *Value) GetStructVal() *StructValue {
	if x != nil {
		if x, ok := x.Kind.(*Value_StructVal); ok {
			return x.StructVal
		}
	}
	return nil
}

func (x *Value) GetListVal() *ListValue {
	if x != nil {
		if x, ok := x.Kind.(*Value_ListVal); ok {
			return x.ListVal
		}
	}
	return nil
}

func (x *Value) GetMapVal() *MapValue {
	if x != nil {
		if x, ok := x.Kind.(*Value_MapVal); ok {
			return x.MapVal
		}
	}
	return nil
}

type isValue_Kind interface {
	isValue_Kind()
}

type Value_StringVal struct {
	// Primitive types
	StringVal string `protobuf:"bytes,1,opt,name=string_val,json=stringVal,proto3,oneof"`
}

type Value_Int64Val struct {
	Int64Val int64 `protobuf:"varint,2,opt,name=int64_val,json=int64Val,proto3,oneof"`
}

type Value_Int32Val struct {
	Int32Val int32 `protobuf:"varint,3,opt,name=int32_val,json=int32Val,proto3,oneof"`
}

type Value_DoubleVal struct {
	DoubleVal float64 `protobuf:"fixed64,4,opt,name=double_val,json=doubleVal,proto3,oneof"`
}

type Value_FloatVal struct {
	FloatVal float32 `protobuf:"fixed32,5,opt,name=float_val,json=floatVal,proto3,oneof"`
}

type Value_BoolVal struct {
	BoolVal bool `protobuf:"varint,6,opt,name=bool_val,json=boolVal,proto3,oneof"`
}

type Value_BytesVal struct {
	BytesVal []byte `protobuf:"bytes,7,opt,name=bytes_val,json=bytesVal,proto3,oneof"`
}

type Value_TimestampMicros struct {
	// Temporal types (microseconds precision)
	TimestampMicros int64 `protobuf:"varint,10,opt,name=timestamp_micros,json=timestampMicros,proto3,oneof"` // Timestamp: microseconds since Unix epoch
}

type Value_DateDays struct {
	DateDays int32 `protobuf:"varint,11,opt,name=date_days,json=dateDays,proto3,oneof"` // Date: days since Unix epoch (1970-01-01)
}

type Value_TimeMicros struct {
	TimeMicros int64 `protobuf:"varint,12,opt,name=time_micros,json=timeMicros,proto3,oneof"` // Time: microseconds since midnight
}

type Value_NullVal struct {
	// Special values
	NullVal NullValue `protobuf:"varint,20,opt,name=null_val,json=nullVal,proto3,enum=datapower.noesis.v1.NullValue,oneof"`
}

type Value_StructVal struct {
	// Nested types (for complex schemas)
	StructVal *StructValue `protobuf:"bytes,21,opt,name=struct_val,json=structVal,proto3,oneof"` // Nested struct/object
}

type Value_ListVal struct {
	ListVal *ListValue `protobuf:"bytes,22,opt,name=list_val,json=listVal,proto3,oneof"` // Array/list
}

type Value_MapVal struct {
	MapVal *MapValue `protobuf:"bytes,23,opt,name=map_val,json=mapVal,proto3,oneof"` // Map/dictionary
}

func (*Value_StringVal) isValue_Kind() {}

func (*Value_Int64Val) isValue_Kind() {}

func (*Value_Int32Val) isValue_Kind() {}

func (*Value_DoubleVal) isValue_Kind() {}

func (*Value_FloatVal) isValue_Kind() {}

func (*Value_BoolVal) isValue_Kind() {}

func (*Value_BytesVal) isValue_Kind() {}

func (*Value_TimestampMicros) isValue_Kind() {}

func (*Value_DateDays) isValue_Kind() {}

func (*Value_TimeMicros) isValue_Kind() {}

func (*Value_NullVal) isValue_Kind() {}

func (*Value_StructVal) isValue_Kind() {}

func (*Value_ListVal) isValue_Kind() {}

func (*Value_MapVal) isValue_Kind() {}

// Struct/object value (nested fields)
type StructValue struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Fields        map[string]*Value      `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StructValue) Reset() {
	*x = StructValue{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StructValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StructValue) ProtoMessage() {}

func (x *StructValue) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StructValue.ProtoReflect.Descriptor instead.
func (*StructValue) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{31}
}

func (x *StructValue) GetFields() map[string]*Value {
	if x != nil {
		return x.Fields
	}
	return nil
}

// List/array value (repeated elements)
type ListValue struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Elements      []*Value               `protobuf:"bytes,1,rep,name=elements,proto3" json:"elements,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListValue) Reset() {
	*x = ListValue{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListValue) ProtoMessage() {}

func (x *ListValue) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListValue.ProtoReflect.Descriptor instead.
func (*ListValue) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{32}
}

func (x *ListValue) GetElements() []*Value {
	if x != nil {
		return x.Elements
	}
	return nil
}

// Map/dictionary value (key-value pairs)
type MapValue struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Entries       map[string]*Value      `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MapValue) Reset() {
	*x = MapValue{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MapValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MapValue) ProtoMessage() {}

func (x *MapValue) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MapValue.ProtoReflect.Descriptor instead.
func (*MapValue) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{33}
}

func (x *MapValue) GetEntries() map[string]*Value {
	if x != nil {
		return x.Entries
	}
	return nil
}

type StateMsg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Cursor        *Cursor                `protobuf:"bytes,1,opt,name=cursor,proto3" json:"cursor,omitempty"`                  // Opaque; sufficient to resume without duplication
	Watermark     int64                  `protobuf:"varint,2,opt,name=watermark,proto3" json:"watermark,omitempty"`           // Max logical timestamp observed so far (epoch millis)
	GroupId       string                 `protobuf:"bytes,3,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"` // For subgraph: optional "group closure" marker
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StateMsg) Reset() {
	*x = StateMsg{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StateMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StateMsg) ProtoMessage() {}

func (x *StateMsg) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StateMsg.ProtoReflect.Descriptor instead.
func (*StateMsg) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{34}
}

func (x *StateMsg) GetCursor() *Cursor {
	if x != nil {
		return x.Cursor
	}
	return nil
}

func (x *StateMsg) GetWatermark() int64 {
	if x != nil {
		return x.Watermark
	}
	return 0
}

func (x *StateMsg) GetGroupId() string {
	if x != nil {
		return x.GroupId
	}
	return ""
}

type Projection struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Columns       []string               `protobuf:"bytes,1,rep,name=columns,proto3" json:"columns,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Projection) Reset() {
	*x = Projection{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Projection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Projection) ProtoMessage() {}

func (x *Projection) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Projection.ProtoReflect.Descriptor instead.
func (*Projection) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{35}
}

func (x *Projection) GetColumns() []string {
	if x != nil {
		return x.Columns
	}
	return nil
}

// Keep Filter simple and vendor-neutral. Use one of:
// - expression: connector-level expression language or SQL-ish string
// - predicates: a simple list of (field, op, value) triplets (optional to implement)
type Filter struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Expression    string                 `protobuf:"bytes,1,opt,name=expression,proto3" json:"expression,omitempty"` // e.g., "updated_at >= '2024-01-01T00:00:00Z' AND status IN ('A','B')"
	Predicates    []*Predicate           `protobuf:"bytes,2,rep,name=predicates,proto3" json:"predicates,omitempty"` // Optional alternative for structured filters
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Filter) Reset() {
	*x = Filter{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Filter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Filter) ProtoMessage() {}

func (x *Filter) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Filter.ProtoReflect.Descriptor instead.
func (*Filter) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{36}
}

func (x *Filter) GetExpression() string {
	if x != nil {
		return x.Expression
	}
	return ""
}

func (x *Filter) GetPredicates() []*Predicate {
	if x != nil {
		return x.Predicates
	}
	return nil
}

type Predicate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Field         string                 `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`   // e.g., "updated_at"
	Op            string                 `protobuf:"bytes,2,opt,name=op,proto3" json:"op,omitempty"`         // e.g., ">", ">=", "=", "IN"
	Values        []string               `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"` // string-encoded values
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Predicate) Reset() {
	*x = Predicate{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Predicate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Predicate) ProtoMessage() {}

func (x *Predicate) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Predicate.ProtoReflect.Descriptor instead.
func (*Predicate) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{37}
}

func (x *Predicate) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *Predicate) GetOp() string {
	if x != nil {
		return x.Op
	}
	return ""
}

func (x *Predicate) GetValues() []string {
	if x != nil {
		return x.Values
	}
	return nil
}

type Ordering struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	By            []*OrderBy             `protobuf:"bytes,1,rep,name=by,proto3" json:"by,omitempty"` // e.g., [{column:"id", direction:ASC}]
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Ordering) Reset() {
	*x = Ordering{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Ordering) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Ordering) ProtoMessage() {}

func (x *Ordering) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Ordering.ProtoReflect.Descriptor instead.
func (*Ordering) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{38}
}

func (x *Ordering) GetBy() []*OrderBy {
	if x != nil {
		return x.By
	}
	return nil
}

type OrderBy struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Column        string                 `protobuf:"bytes,1,opt,name=column,proto3" json:"column,omitempty"`
	Direction     Direction              `protobuf:"varint,2,opt,name=direction,proto3,enum=datapower.noesis.v1.Direction" json:"direction,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OrderBy) Reset() {
	*x = OrderBy{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OrderBy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderBy) ProtoMessage() {}

func (x *OrderBy) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrderBy.ProtoReflect.Descriptor instead.
func (*OrderBy) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{39}
}

func (x *OrderBy) GetColumn() string {
	if x != nil {
		return x.Column
	}
	return ""
}

func (x *OrderBy) GetDirection() Direction {
	if x != nil {
		return x.Direction
	}
	return Direction_DIR_UNSPECIFIED
}

// Snapshot consistency hints. The connector should pick the strongest available option.
type SnapshotOptions struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Mode          ConsistencyMode        `protobuf:"varint,1,opt,name=mode,proto3,enum=datapower.noesis.v1.ConsistencyMode" json:"mode,omitempty"` // Desired consistency level
	AsOf          string                 `protobuf:"bytes,2,opt,name=as_of,json=asOf,proto3" json:"as_of,omitempty"`                               // Optional: timestamp/SCN/LSN string for "AS OF" reads
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SnapshotOptions) Reset() {
	*x = SnapshotOptions{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SnapshotOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SnapshotOptions) ProtoMessage() {}

func (x *SnapshotOptions) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SnapshotOptions.ProtoReflect.Descriptor instead.
func (*SnapshotOptions) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{40}
}

func (x *SnapshotOptions) GetMode() ConsistencyMode {
	if x != nil {
		return x.Mode
	}
	return ConsistencyMode_CONSISTENCY_UNSPECIFIED
}

func (x *SnapshotOptions) GetAsOf() string {
	if x != nil {
		return x.AsOf
	}
	return ""
}

type Cursor struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Token         []byte                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cursor) Reset() {
	*x = Cursor{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cursor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cursor) ProtoMessage() {}

func (x *Cursor) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cursor.ProtoReflect.Descriptor instead.
func (*Cursor) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{41}
}

func (x *Cursor) GetToken() []byte {
	if x != nil {
		return x.Token
	}
	return nil
}

type RateLimit struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Qps           int32                  `protobuf:"varint,1,opt,name=qps,proto3" json:"qps,omitempty"`                 // Max requests per second (best-effort)
	Parallelism   int32                  `protobuf:"varint,2,opt,name=parallelism,proto3" json:"parallelism,omitempty"` // Internal parallelism for fetching
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RateLimit) Reset() {
	*x = RateLimit{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RateLimit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimit) ProtoMessage() {}

func (x *RateLimit) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimit.ProtoReflect.Descriptor instead.
func (*RateLimit) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{42}
}

func (x *RateLimit) GetQps() int32 {
	if x != nil {
		return x.Qps
	}
	return 0
}

func (x *RateLimit) GetParallelism() int32 {
	if x != nil {
		return x.Parallelism
	}
	return 0
}

// Subgraph traversal policy (PLM/graph scenarios).
type Traversal struct {
	state                      protoimpl.MessageState `protogen:"open.v1"`
	AllowedLinkEntities        []string               `protobuf:"bytes,1,rep,name=allowed_link_entities,json=allowedLinkEntities,proto3" json:"allowed_link_entities,omitempty"`                       // LINK entity names allowed during traversal (e.g., ["BOMLink","PartDocLink"])
	MaxDepth                   int32                  `protobuf:"varint,2,opt,name=max_depth,json=maxDepth,proto3" json:"max_depth,omitempty"`                                                         // -1 = unlimited; 0 = only the head; N = max depth
	Direction                  TraversalDirection     `protobuf:"varint,3,opt,name=direction,proto3,enum=datapower.noesis.v1.TraversalDirection" json:"direction,omitempty"`                           // OUTBOUND/INBOUND/BOTH
	AllowRevisit               bool                   `protobuf:"varint,4,opt,name=allow_revisit,json=allowRevisit,proto3" json:"allow_revisit,omitempty"`                                             // If false, connector must maintain a visited set
	StrictReferentialIntegrity bool                   `protobuf:"varint,5,opt,name=strict_referential_integrity,json=strictReferentialIntegrity,proto3" json:"strict_referential_integrity,omitempty"` // If true, missing references should be surfaced via LOG and/or error policy
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *Traversal) Reset() {
	*x = Traversal{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Traversal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Traversal) ProtoMessage() {}

func (x *Traversal) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Traversal.ProtoReflect.Descriptor instead.
func (*Traversal) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{43}
}

func (x *Traversal) GetAllowedLinkEntities() []string {
	if x != nil {
		return x.AllowedLinkEntities
	}
	return nil
}

func (x *Traversal) GetMaxDepth() int32 {
	if x != nil {
		return x.MaxDepth
	}
	return 0
}

func (x *Traversal) GetDirection() TraversalDirection {
	if x != nil {
		return x.Direction
	}
	return TraversalDirection_TRAV_DIR_UNSPECIFIED
}

func (x *Traversal) GetAllowRevisit() bool {
	if x != nil {
		return x.AllowRevisit
	}
	return false
}

func (x *Traversal) GetStrictReferentialIntegrity() bool {
	if x != nil {
		return x.StrictReferentialIntegrity
	}
	return false
}

// Optional schema re-broadcast during Read (e.g., on evolution or first message per entity).
type SchemaMsg struct {
	state         protoimpl.MessageState      `protogen:"open.v1"`
	Entity        string                      `protobuf:"bytes,1,opt,name=entity,proto3" json:"entity,omitempty"`
	Schema        *StructuredSchemaDescriptor `protobuf:"bytes,2,opt,name=schema,proto3" json:"schema,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchemaMsg) Reset() {
	*x = SchemaMsg{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaMsg) ProtoMessage() {}

func (x *SchemaMsg) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaMsg.ProtoReflect.Descriptor instead.
func (*SchemaMsg) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{44}
}

func (x *SchemaMsg) GetEntity() string {
	if x != nil {
		return x.Entity
	}
	return ""
}

func (x *SchemaMsg) GetSchema() *StructuredSchemaDescriptor {
	if x != nil {
		return x.Schema
	}
	return nil
}

// Basic structured logs and lightweight metrics to help with observability.
type LogMsg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Level         string                 `protobuf:"bytes,1,opt,name=level,proto3" json:"level,omitempty"` // "INFO","WARN","ERROR","DEBUG"
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Kv            map[string]string      `protobuf:"bytes,3,rep,name=kv,proto3" json:"kv,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // e.g., {"tenant":"t42","entity":"Part","code":"AUTH_RATE_LIMIT"}
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogMsg) Reset() {
	*x = LogMsg{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogMsg) ProtoMessage() {}

func (x *LogMsg) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogMsg.ProtoReflect.Descriptor instead.
func (*LogMsg) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{45}
}

func (x *LogMsg) GetLevel() string {
	if x != nil {
		return x.Level
	}
	return ""
}

func (x *LogMsg) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *LogMsg) GetKv() map[string]string {
	if x != nil {
		return x.Kv
	}
	return nil
}

type MetricMsg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"` // e.g., "records_emitted", "api_latency_ms"
	Value         float64                `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
	Tags          map[string]string      `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // e.g., {"entity":"Part","mode":"full_table"}
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MetricMsg) Reset() {
	*x = MetricMsg{}
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MetricMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetricMsg) ProtoMessage() {}

func (x *MetricMsg) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_connector_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetricMsg.ProtoReflect.Descriptor instead.
func (*MetricMsg) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_connector_proto_rawDescGZIP(), []int{46}
}

func (x *MetricMsg) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *MetricMsg) GetValue() float64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *MetricMsg) GetTags() map[string]string {
	if x != nil {
		return x.Tags
	}
	return nil
}

var File_datapower_noesis_v1_connector_proto protoreflect.FileDescriptor

const file_datapower_noesis_v1_connector_proto_rawDesc = "" +
	"\n" +
	"#datapower/noesis/v1/connector.proto\x12\x13datapower.noesis.v1\"|\n" +
	"\x0fDiscoverRequest\x12\x1b\n" +
	"\ttenant_id\x18\x01 \x01(\tR\btenantId\x12#\n" +
	"\rentity_filter\x18\x02 \x03(\tR\fentityFilter\x12'\n" +
	"\x0finclude_schemas\x18\x03 \x01(\bR\x0eincludeSchemas\"\x94\x01\n" +
	"\x10DiscoverResponse\x12=\n" +
	"\bplatform\x18\x01 \x01(\v2!.datapower.noesis.v1.PlatformInfoR\bplatform\x12A\n" +
	"\bentities\x18\x02 \x03(\v2%.datapower.noesis.v1.EntityDescriptorR\bentities\"\xea\x01\n" +
	"\fPlatformInfo\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x16\n" +
	"\x06vendor\x18\x02 \x01(\tR\x06vendor\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\x1a\n" +
	"\btimezone\x18\x04 \x01(\tR\btimezone\x12?\n" +
	"\x04tags\x18\x05 \x03(\v2+.datapower.noesis.v1.PlatformInfo.TagsEntryR\x04tags\x1a7\n" +
	"\tTagsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xb6\x05\n" +
	"\x10EntityDescriptor\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x123\n" +
	"\x04kind\x18\x02 \x01(\x0e2\x1f.datapower.noesis.v1.EntityKindR\x04kind\x12!\n" +
	"\fdisplay_name\x18\x03 \x01(\tR\vdisplayName\x12 \n" +
	"\vdescription\x18\x04 \x01(\tR\vdescription\x12G\n" +
	"\x06schema\x18\x05 \x01(\v2/.datapower.noesis.v1.StructuredSchemaDescriptorR\x06schema\x12\x1f\n" +
	"\vprimary_key\x18\x06 \x03(\tR\n" +
	"primaryKey\x12?\n" +
	"\vunique_keys\x18\a \x03(\v2\x1e.datapower.noesis.v1.UniqueKeyR\n" +
	"uniqueKeys\x12\x1f\n" +
	"\vsoft_delete\x18\b \x01(\bR\n" +
	"softDelete\x12*\n" +
	"\x11soft_delete_field\x18\t \x01(\tR\x0fsoftDeleteField\x123\n" +
	"\x03src\x18\n" +
	" \x01(\v2!.datapower.noesis.v1.LinkEndpointR\x03src\x123\n" +
	"\x03dst\x18\v \x01(\v2!.datapower.noesis.v1.LinkEndpointR\x03dst\x12:\n" +
	"\acursors\x18\f \x03(\v2 .datapower.noesis.v1.CursorFieldR\acursors\x12O\n" +
	"\fcapabilities\x18\r \x01(\v2+.datapower.noesis.v1.ExtractionCapabilitiesR\fcapabilities\x12%\n" +
	"\x0eestimated_rows\x18\x0e \x01(\x03R\restimatedRows\"\xc2\x04\n" +
	"\x0fFieldDescriptor\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x122\n" +
	"\x04type\x18\x02 \x01(\x0e2\x1e.datapower.noesis.v1.FieldTypeR\x04type\x12\x1a\n" +
	"\bnullable\x18\x03 \x01(\bR\bnullable\x12#\n" +
	"\rdefault_value\x18\x04 \x01(\tR\fdefaultValue\x12$\n" +
	"\rdocumentation\x18\x05 \x01(\tR\rdocumentation\x12\x1d\n" +
	"\n" +
	"max_length\x18\x06 \x01(\x05R\tmaxLength\x12\x1c\n" +
	"\tprecision\x18\a \x01(\x05R\tprecision\x12\x14\n" +
	"\x05scale\x18\b \x01(\x05R\x05scale\x12\x1f\n" +
	"\venum_values\x18\t \x03(\tR\n" +
	"enumValues\x12L\n" +
	"\x12array_element_type\x18\n" +
	" \x01(\x0e2\x1e.datapower.noesis.v1.FieldTypeR\x10arrayElementType\x12)\n" +
	"\x10ordinal_position\x18\v \x01(\x05R\x0fordinalPosition\x12T\n" +
	"\n" +
	"attributes\x18\f \x03(\v24.datapower.noesis.v1.FieldDescriptor.AttributesEntryR\n" +
	"attributes\x1a=\n" +
	"\x0fAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xfc\x03\n" +
	"\x14ConstraintDescriptor\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x127\n" +
	"\x04type\x18\x02 \x01(\x0e2#.datapower.noesis.v1.ConstraintTypeR\x04type\x12\x18\n" +
	"\acolumns\x18\x03 \x03(\tR\acolumns\x12)\n" +
	"\x10referenced_table\x18\x04 \x01(\tR\x0freferencedTable\x12-\n" +
	"\x12referenced_columns\x18\x05 \x03(\tR\x11referencedColumns\x12\x1b\n" +
	"\ton_delete\x18\x06 \x01(\tR\bonDelete\x12\x1b\n" +
	"\ton_update\x18\a \x01(\tR\bonUpdate\x12)\n" +
	"\x10check_expression\x18\b \x01(\tR\x0fcheckExpression\x12$\n" +
	"\rdocumentation\x18\t \x01(\tR\rdocumentation\x12Y\n" +
	"\n" +
	"attributes\x18\n" +
	" \x03(\v29.datapower.noesis.v1.ConstraintDescriptor.AttributesEntryR\n" +
	"attributes\x1a=\n" +
	"\x0fAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xc4\x02\n" +
	"\x0fIndexDescriptor\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\acolumns\x18\x02 \x03(\tR\acolumns\x12\x16\n" +
	"\x06unique\x18\x03 \x01(\bR\x06unique\x12\x12\n" +
	"\x04type\x18\x04 \x01(\tR\x04type\x12\x1c\n" +
	"\tcondition\x18\x05 \x01(\tR\tcondition\x12$\n" +
	"\rdocumentation\x18\x06 \x01(\tR\rdocumentation\x12T\n" +
	"\n" +
	"attributes\x18\a \x03(\v24.datapower.noesis.v1.IndexDescriptor.AttributesEntryR\n" +
	"attributes\x1a=\n" +
	"\x0fAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xa4\x03\n" +
	"\x1aStructuredSchemaDescriptor\x12\x1b\n" +
	"\tschema_id\x18\x01 \x01(\tR\bschemaId\x12<\n" +
	"\x06fields\x18\x02 \x03(\v2$.datapower.noesis.v1.FieldDescriptorR\x06fields\x12K\n" +
	"\vconstraints\x18\x03 \x03(\v2).datapower.noesis.v1.ConstraintDescriptorR\vconstraints\x12>\n" +
	"\aindexes\x18\x04 \x03(\v2$.datapower.noesis.v1.IndexDescriptorR\aindexes\x12_\n" +
	"\n" +
	"attributes\x18\x05 \x03(\v2?.datapower.noesis.v1.StructuredSchemaDescriptor.AttributesEntryR\n" +
	"attributes\x1a=\n" +
	"\x0fAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"%\n" +
	"\tUniqueKey\x12\x18\n" +
	"\acolumns\x18\x01 \x03(\tR\acolumns\"E\n" +
	"\fLinkEndpoint\x12\x16\n" +
	"\x06entity\x18\x01 \x01(\tR\x06entity\x12\x1d\n" +
	"\n" +
	"key_fields\x18\x02 \x03(\tR\tkeyFields\"v\n" +
	"\vCursorField\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x123\n" +
	"\x04type\x18\x02 \x01(\x0e2\x1f.datapower.noesis.v1.CursorTypeR\x04type\x12\x1c\n" +
	"\tmonotonic\x18\x03 \x01(\bR\tmonotonic\"\xd4\x03\n" +
	"\x16ExtractionCapabilities\x12.\n" +
	"\x13supports_full_table\x18\x01 \x01(\bR\x11supportsFullTable\x124\n" +
	"\x16supports_change_stream\x18\x02 \x01(\bR\x14supportsChangeStream\x12+\n" +
	"\x11supports_subgraph\x18\x03 \x01(\bR\x10supportsSubgraph\x12/\n" +
	"\x13supports_projection\x18\n" +
	" \x01(\bR\x12supportsProjection\x12'\n" +
	"\x0fsupports_filter\x18\v \x01(\bR\x0esupportsFilter\x12+\n" +
	"\x11supports_ordering\x18\f \x01(\bR\x10supportsOrdering\x12)\n" +
	"\x10orderable_fields\x18\r \x03(\tR\x0forderableFields\x124\n" +
	"\x16subgraph_link_entities\x18\x14 \x03(\tR\x14subgraphLinkEntities\x12?\n" +
	"\x1csubgraph_max_depth_supported\x18\x15 \x01(\x05R\x19subgraphMaxDepthSupported\"\xad\x01\n" +
	"\fCheckRequest\x12\x1b\n" +
	"\ttenant_id\x18\x01 \x01(\tR\btenantId\x12E\n" +
	"\x06config\x18\x02 \x03(\v2-.datapower.noesis.v1.CheckRequest.ConfigEntryR\x06config\x1a9\n" +
	"\vConfigEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xc0\x01\n" +
	"\rCheckResponse\x12\x0e\n" +
	"\x02ok\x18\x01 \x01(\bR\x02ok\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12I\n" +
	"\adetails\x18\x03 \x03(\v2/.datapower.noesis.v1.CheckResponse.DetailsEntryR\adetails\x1a:\n" +
	"\fDetailsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xab\x01\n" +
	"\vOpenRequest\x12\x1b\n" +
	"\ttenant_id\x18\x01 \x01(\tR\btenantId\x12D\n" +
	"\x06config\x18\x02 \x03(\v2,.datapower.noesis.v1.OpenRequest.ConfigEntryR\x06config\x1a9\n" +
	"\vConfigEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\\\n" +
	"\fOpenResponse\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12-\n" +
	"\x13expires_at_epoch_ms\x18\x02 \x01(\x03R\x10expiresAtEpochMs\"-\n" +
	"\fCloseRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\"\x0f\n" +
	"\rCloseResponse\"\xff\x02\n" +
	"\x15PlanExtractionRequest\x12\x1b\n" +
	"\ttenant_id\x18\x01 \x01(\tR\btenantId\x12\x16\n" +
	"\x06entity\x18\x02 \x01(\tR\x06entity\x12/\n" +
	"\x13desired_parallelism\x18\x03 \x01(\x05R\x12desiredParallelism\x12N\n" +
	"\x06config\x18\x04 \x03(\v26.datapower.noesis.v1.PlanExtractionRequest.ConfigEntryR\x06config\x123\n" +
	"\x06filter\x18\x05 \x01(\v2\x1b.datapower.noesis.v1.FilterR\x06filter\x12@\n" +
	"\bsnapshot\x18\x06 \x01(\v2$.datapower.noesis.v1.SnapshotOptionsR\bsnapshot\x1a9\n" +
	"\vConfigEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xa9\x01\n" +
	"\x16PlanExtractionResponse\x12<\n" +
	"\x06splits\x18\x01 \x03(\v2$.datapower.noesis.v1.ExtractionSplitR\x06splits\x12\x1f\n" +
	"\vsnapshot_id\x18\x02 \x01(\tR\n" +
	"snapshotId\x120\n" +
	"\x14total_estimated_rows\x18\x03 \x01(\x03R\x12totalEstimatedRows\"\x81\x02\n" +
	"\x0fExtractionSplit\x12\x19\n" +
	"\bsplit_id\x18\x01 \x01(\tR\asplitId\x12\x1f\n" +
	"\vsplit_token\x18\x02 \x01(\fR\n" +
	"splitToken\x12%\n" +
	"\x0eestimated_rows\x18\x03 \x01(\x03R\restimatedRows\x12N\n" +
	"\bmetadata\x18\x04 \x03(\v22.datapower.noesis.v1.ExtractionSplit.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xa4\x02\n" +
	"\x10ReadSplitRequest\x12\x1b\n" +
	"\ttenant_id\x18\x01 \x01(\tR\btenantId\x12\x16\n" +
	"\x06entity\x18\x02 \x01(\tR\x06entity\x12:\n" +
	"\x05split\x18\x03 \x01(\v2$.datapower.noesis.v1.ExtractionSplitR\x05split\x12\x1f\n" +
	"\vsnapshot_id\x18\x04 \x01(\tR\n" +
	"snapshotId\x12?\n" +
	"\n" +
	"projection\x18\x05 \x01(\v2\x1f.datapower.noesis.v1.ProjectionR\n" +
	"projection\x12=\n" +
	"\n" +
	"rate_limit\x18\x06 \x01(\v2\x1e.datapower.noesis.v1.RateLimitR\trateLimit\"\x84\x03\n" +
	"\vReadRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12C\n" +
	"\n" +
	"full_table\x18\n" +
	" \x01(\v2\".datapower.noesis.v1.FullTableScanH\x00R\tfullTable\x12H\n" +
	"\rchange_stream\x18\v \x01(\v2!.datapower.noesis.v1.ChangeStreamH\x00R\fchangeStream\x12?\n" +
	"\bsubgraph\x18\f \x01(\v2!.datapower.noesis.v1.SubgraphReadH\x00R\bsubgraph\x12?\n" +
	"\n" +
	"projection\x18\x02 \x01(\v2\x1f.datapower.noesis.v1.ProjectionR\n" +
	"projection\x12=\n" +
	"\n" +
	"rate_limit\x18\x03 \x01(\v2\x1e.datapower.noesis.v1.RateLimitR\trateLimitB\x06\n" +
	"\x04mode\"\x97\x02\n" +
	"\rFullTableScan\x12\x16\n" +
	"\x06entity\x18\x01 \x01(\tR\x06entity\x12<\n" +
	"\vresume_from\x18\x02 \x01(\v2\x1b.datapower.noesis.v1.CursorR\n" +
	"resumeFrom\x123\n" +
	"\x06filter\x18\x03 \x01(\v2\x1b.datapower.noesis.v1.FilterR\x06filter\x129\n" +
	"\bordering\x18\x04 \x01(\v2\x1d.datapower.noesis.v1.OrderingR\bordering\x12@\n" +
	"\bsnapshot\x18\x05 \x01(\v2$.datapower.noesis.v1.SnapshotOptionsR\bsnapshot\"\x8c\x01\n" +
	"\fChangeStream\x12\x16\n" +
	"\x06entity\x18\x01 \x01(\tR\x06entity\x12/\n" +
	"\x04from\x18\x02 \x01(\v2\x1b.datapower.noesis.v1.CursorR\x04from\x123\n" +
	"\x06filter\x18\x03 \x01(\v2\x1b.datapower.noesis.v1.FilterR\x06filter\"\xfd\x01\n" +
	"\fSubgraphRead\x12/\n" +
	"\x05heads\x18\x01 \x03(\v2\x19.datapower.noesis.v1.HeadR\x05heads\x12<\n" +
	"\ttraversal\x18\x02 \x01(\v2\x1e.datapower.noesis.v1.TraversalR\ttraversal\x12@\n" +
	"\bsnapshot\x18\x03 \x01(\v2$.datapower.noesis.v1.SnapshotOptionsR\bsnapshot\x12<\n" +
	"\vresume_from\x18\x04 \x01(\v2\x1b.datapower.noesis.v1.CursorR\n" +
	"resumeFrom\"0\n" +
	"\x04Head\x12\x16\n" +
	"\x06entity\x18\x01 \x01(\tR\x06entity\x12\x10\n" +
	"\x03key\x18\x02 \x01(\tR\x03key\"\xaa\x02\n" +
	"\vReadMessage\x128\n" +
	"\x06schema\x18\x01 \x01(\v2\x1e.datapower.noesis.v1.SchemaMsgH\x00R\x06schema\x128\n" +
	"\x06record\x18\x02 \x01(\v2\x1e.datapower.noesis.v1.RecordMsgH\x00R\x06record\x125\n" +
	"\x05state\x18\x03 \x01(\v2\x1d.datapower.noesis.v1.StateMsgH\x00R\x05state\x12/\n" +
	"\x03log\x18\x04 \x01(\v2\x1b.datapower.noesis.v1.LogMsgH\x00R\x03log\x128\n" +
	"\x06metric\x18\x05 \x01(\v2\x1e.datapower.noesis.v1.MetricMsgH\x00R\x06metricB\x05\n" +
	"\x03msg\"\xd6\x01\n" +
	"\tRecordMsg\x12\x16\n" +
	"\x06entity\x18\x01 \x01(\tR\x06entity\x12,\n" +
	"\x04data\x18\x02 \x01(\v2\x18.datapower.noesis.v1.RowR\x04data\x12'\n" +
	"\x02op\x18\x03 \x01(\x0e2\x17.datapower.noesis.v1.OpR\x02op\x12\"\n" +
	"\revent_time_ms\x18\x04 \x01(\x03R\veventTimeMs\x12\x1b\n" +
	"\tschema_id\x18\x05 \x01(\tR\bschemaId\x12\x19\n" +
	"\bgroup_id\x18\x06 \x01(\tR\agroupId\"\x9e\x01\n" +
	"\x03Row\x12?\n" +
	"\acolumns\x18\x01 \x03(\v2%.datapower.noesis.v1.Row.ColumnsEntryR\acolumns\x1aV\n" +
	"\fColumnsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x120\n" +
	"\x05value\x18\x02 \x01(\v2\x1a.datapower.noesis.v1.ValueR\x05value:\x028\x01\"\xd0\x04\n" +
	"\x05Value\x12\x1f\n" +
	"\n" +
	"string_val\x18\x01 \x01(\tH\x00R\tstringVal\x12\x1d\n" +
	"\tint64_val\x18\x02 \x01(\x03H\x00R\bint64Val\x12\x1d\n" +
	"\tint32_val\x18\x03 \x01(\x05H\x00R\bint32Val\x12\x1f\n" +
	"\n" +
	"double_val\x18\x04 \x01(\x01H\x00R\tdoubleVal\x12\x1d\n" +
	"\tfloat_val\x18\x05 \x01(\x02H\x00R\bfloatVal\x12\x1b\n" +
	"\bbool_val\x18\x06 \x01(\bH\x00R\aboolVal\x12\x1d\n" +
	"\tbytes_val\x18\a \x01(\fH\x00R\bbytesVal\x12+\n" +
	"\x10timestamp_micros\x18\n" +
	" \x01(\x03H\x00R\x0ftimestampMicros\x12\x1d\n" +
	"\tdate_days\x18\v \x01(\x05H\x00R\bdateDays\x12!\n" +
	"\vtime_micros\x18\f \x01(\x03H\x00R\n" +
	"timeMicros\x12;\n" +
	"\bnull_val\x18\x14 \x01(\x0e2\x1e.datapower.noesis.v1.NullValueH\x00R\anullVal\x12A\n" +
	"\n" +
	"struct_val\x18\x15 \x01(\v2 .datapower.noesis.v1.StructValueH\x00R\tstructVal\x12;\n" +
	"\blist_val\x18\x16 \x01(\v2\x1e.datapower.noesis.v1.ListValueH\x00R\alistVal\x128\n" +
	"\amap_val\x18\x17 \x01(\v2\x1d.datapower.noesis.v1.MapValueH\x00R\x06mapValB\x06\n" +
	"\x04kind\"\xaa\x01\n" +
	"\vStructValue\x12D\n" +
	"\x06fields\x18\x01 \x03(\v2,.datapower.noesis.v1.StructValue.FieldsEntryR\x06fields\x1aU\n" +
	"\vFieldsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x120\n" +
	"\x05value\x18\x02 \x01(\v2\x1a.datapower.noesis.v1.ValueR\x05value:\x028\x01\"C\n" +
	"\tListValue\x126\n" +
	"\belements\x18\x01 \x03(\v2\x1a.datapower.noesis.v1.ValueR\belements\"\xa8\x01\n" +
	"\bMapValue\x12D\n" +
	"\aentries\x18\x01 \x03(\v2*.datapower.noesis.v1.MapValue.EntriesEntryR\aentries\x1aV\n" +
	"\fEntriesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x120\n" +
	"\x05value\x18\x02 \x01(\v2\x1a.datapower.noesis.v1.ValueR\x05value:\x028\x01\"x\n" +
	"\bStateMsg\x123\n" +
	"\x06cursor\x18\x01 \x01(\v2\x1b.datapower.noesis.v1.CursorR\x06cursor\x12\x1c\n" +
	"\twatermark\x18\x02 \x01(\x03R\twatermark\x12\x19\n" +
	"\bgroup_id\x18\x03 \x01(\tR\agroupId\"&\n" +
	"\n" +
	"Projection\x12\x18\n" +
	"\acolumns\x18\x01 \x03(\tR\acolumns\"h\n" +
	"\x06Filter\x12\x1e\n" +
	"\n" +
	"expression\x18\x01 \x01(\tR\n" +
	"expression\x12>\n" +
	"\n" +
	"predicates\x18\x02 \x03(\v2\x1e.datapower.noesis.v1.PredicateR\n" +
	"predicates\"I\n" +
	"\tPredicate\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x12\x0e\n" +
	"\x02op\x18\x02 \x01(\tR\x02op\x12\x16\n" +
	"\x06values\x18\x03 \x03(\tR\x06values\"8\n" +
	"\bOrdering\x12,\n" +
	"\x02by\x18\x01 \x03(\v2\x1c.datapower.noesis.v1.OrderByR\x02by\"_\n" +
	"\aOrderBy\x12\x16\n" +
	"\x06column\x18\x01 \x01(\tR\x06column\x12<\n" +
	"\tdirection\x18\x02 \x01(\x0e2\x1e.datapower.noesis.v1.DirectionR\tdirection\"`\n" +
	"\x0fSnapshotOptions\x128\n" +
	"\x04mode\x18\x01 \x01(\x0e2$.datapower.noesis.v1.ConsistencyModeR\x04mode\x12\x13\n" +
	"\x05as_of\x18\x02 \x01(\tR\x04asOf\"\x1e\n" +
	"\x06Cursor\x12\x14\n" +
	"\x05token\x18\x01 \x01(\fR\x05token\"?\n" +
	"\tRateLimit\x12\x10\n" +
	"\x03qps\x18\x01 \x01(\x05R\x03qps\x12 \n" +
	"\vparallelism\x18\x02 \x01(\x05R\vparallelism\"\x8a\x02\n" +
	"\tTraversal\x122\n" +
	"\x15allowed_link_entities\x18\x01 \x03(\tR\x13allowedLinkEntities\x12\x1b\n" +
	"\tmax_depth\x18\x02 \x01(\x05R\bmaxDepth\x12E\n" +
	"\tdirection\x18\x03 \x01(\x0e2'.datapower.noesis.v1.TraversalDirectionR\tdirection\x12#\n" +
	"\rallow_revisit\x18\x04 \x01(\bR\fallowRevisit\x12@\n" +
	"\x1cstrict_referential_integrity\x18\x05 \x01(\bR\x1astrictReferentialIntegrity\"l\n" +
	"\tSchemaMsg\x12\x16\n" +
	"\x06entity\x18\x01 \x01(\tR\x06entity\x12G\n" +
	"\x06schema\x18\x02 \x01(\v2/.datapower.noesis.v1.StructuredSchemaDescriptorR\x06schema\"\xa4\x01\n" +
	"\x06LogMsg\x12\x14\n" +
	"\x05level\x18\x01 \x01(\tR\x05level\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x123\n" +
	"\x02kv\x18\x03 \x03(\v2#.datapower.noesis.v1.LogMsg.KvEntryR\x02kv\x1a5\n" +
	"\aKvEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xac\x01\n" +
	"\tMetricMsg\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x01R\x05value\x12<\n" +
	"\x04tags\x18\x03 \x03(\v2(.datapower.noesis.v1.MetricMsg.TagsEntryR\x04tags\x1a7\n" +
	"\tTagsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01*6\n" +
	"\n" +
	"EntityKind\x12\x14\n" +
	"\x10KIND_UNSPECIFIED\x10\x00\x12\b\n" +
	"\x04NODE\x10\x01\x12\b\n" +
	"\x04LINK\x10\x02*\xe0\x03\n" +
	"\tFieldType\x12\x1a\n" +
	"\x16FIELD_TYPE_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11FIELD_TYPE_STRING\x10\x01\x12\x16\n" +
	"\x12FIELD_TYPE_INTEGER\x10\x02\x12\x15\n" +
	"\x11FIELD_TYPE_BIGINT\x10\x03\x12\x17\n" +
	"\x13FIELD_TYPE_SMALLINT\x10\x04\x12\x16\n" +
	"\x12FIELD_TYPE_DECIMAL\x10\x05\x12\x14\n" +
	"\x10FIELD_TYPE_FLOAT\x10\x06\x12\x15\n" +
	"\x11FIELD_TYPE_DOUBLE\x10\a\x12\x16\n" +
	"\x12FIELD_TYPE_BOOLEAN\x10\b\x12\x13\n" +
	"\x0fFIELD_TYPE_DATE\x10\t\x12\x13\n" +
	"\x0fFIELD_TYPE_TIME\x10\n" +
	"\x12\x18\n" +
	"\x14FIELD_TYPE_TIMESTAMP\x10\v\x12 \n" +
	"\x1cFIELD_TYPE_TIMESTAMP_WITH_TZ\x10\f\x12\x13\n" +
	"\x0fFIELD_TYPE_JSON\x10\r\x12\x14\n" +
	"\x10FIELD_TYPE_JSONB\x10\x0e\x12\x13\n" +
	"\x0fFIELD_TYPE_UUID\x10\x0f\x12\x15\n" +
	"\x11FIELD_TYPE_BINARY\x10\x10\x12\x13\n" +
	"\x0fFIELD_TYPE_TEXT\x10\x11\x12\x13\n" +
	"\x0fFIELD_TYPE_ENUM\x10\x12\x12\x14\n" +
	"\x10FIELD_TYPE_ARRAY\x10\x13*x\n" +
	"\x0eConstraintType\x12\x1f\n" +
	"\x1bCONSTRAINT_TYPE_UNSPECIFIED\x10\x00\x12\x0f\n" +
	"\vPRIMARY_KEY\x10\x01\x12\x0f\n" +
	"\vFOREIGN_KEY\x10\x02\x12\n" +
	"\n" +
	"\x06UNIQUE\x10\x03\x12\t\n" +
	"\x05CHECK\x10\x04\x12\f\n" +
	"\bNOT_NULL\x10\x05*_\n" +
	"\n" +
	"CursorType\x12\x1b\n" +
	"\x17CURSOR_TYPE_UNSPECIFIED\x10\x00\x12\r\n" +
	"\tTIMESTAMP\x10\x01\x12\x10\n" +
	"\fINCREMENTING\x10\x02\x12\a\n" +
	"\x03LSN\x10\x03\x12\n" +
	"\n" +
	"\x06OPAQUE\x10\x04*0\n" +
	"\x02Op\x12\x12\n" +
	"\x0eOP_UNSPECIFIED\x10\x00\x12\n" +
	"\n" +
	"\x06UPSERT\x10\x01\x12\n" +
	"\n" +
	"\x06DELETE\x10\x02*\x1b\n" +
	"\tNullValue\x12\x0e\n" +
	"\n" +
	"NULL_VALUE\x10\x00*3\n" +
	"\tDirection\x12\x13\n" +
	"\x0fDIR_UNSPECIFIED\x10\x00\x12\a\n" +
	"\x03ASC\x10\x01\x12\b\n" +
	"\x04DESC\x10\x02*k\n" +
	"\x0fConsistencyMode\x12\x1b\n" +
	"\x17CONSISTENCY_UNSPECIFIED\x10\x00\x12\x12\n" +
	"\x0eREAD_COMMITTED\x10\x01\x12\x13\n" +
	"\x0fREPEATABLE_READ\x10\x02\x12\x12\n" +
	"\x0eSNAPSHOT_AS_OF\x10\x03*S\n" +
	"\x12TraversalDirection\x12\x18\n" +
	"\x14TRAV_DIR_UNSPECIFIED\x10\x00\x12\f\n" +
	"\bOUTBOUND\x10\x01\x12\v\n" +
	"\aINBOUND\x10\x02\x12\b\n" +
	"\x04BOTH\x10\x032\xe2\x04\n" +
	"\tConnector\x12N\n" +
	"\x05Check\x12!.datapower.noesis.v1.CheckRequest\x1a\".datapower.noesis.v1.CheckResponse\x12W\n" +
	"\bDiscover\x12$.datapower.noesis.v1.DiscoverRequest\x1a%.datapower.noesis.v1.DiscoverResponse\x12i\n" +
	"\x0ePlanExtraction\x12*.datapower.noesis.v1.PlanExtractionRequest\x1a+.datapower.noesis.v1.PlanExtractionResponse\x12K\n" +
	"\x04Open\x12 .datapower.noesis.v1.OpenRequest\x1a!.datapower.noesis.v1.OpenResponse\x12L\n" +
	"\x04Read\x12 .datapower.noesis.v1.ReadRequest\x1a .datapower.noesis.v1.ReadMessage0\x01\x12V\n" +
	"\tReadSplit\x12%.datapower.noesis.v1.ReadSplitRequest\x1a .datapower.noesis.v1.ReadMessage0\x01\x12N\n" +
	"\x05Close\x12!.datapower.noesis.v1.CloseRequest\x1a\".datapower.noesis.v1.CloseResponseBk\n" +
	"\x13datapower.noesis.v1P\x01ZRgithub.com/data-power-io/noesis-protocol/languages/go/datapower/noesis/v1;noesisv1b\x06proto3"

var (
	file_datapower_noesis_v1_connector_proto_rawDescOnce sync.Once
	file_datapower_noesis_v1_connector_proto_rawDescData []byte
)

func file_datapower_noesis_v1_connector_proto_rawDescGZIP() []byte {
	file_datapower_noesis_v1_connector_proto_rawDescOnce.Do(func() {
		file_datapower_noesis_v1_connector_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_datapower_noesis_v1_connector_proto_rawDesc), len(file_datapower_noesis_v1_connector_proto_rawDesc)))
	})
	return file_datapower_noesis_v1_connector_proto_rawDescData
}

var file_datapower_noesis_v1_connector_proto_enumTypes = make([]protoimpl.EnumInfo, 9)
var file_datapower_noesis_v1_connector_proto_msgTypes = make([]protoimpl.MessageInfo, 62)
var file_datapower_noesis_v1_connector_proto_goTypes = []any{
	(EntityKind)(0),                    // 0: datapower.noesis.v1.EntityKind
	(FieldType)(0),                     // 1: datapower.noesis.v1.FieldType
	(ConstraintType)(0),                // 2: datapower.noesis.v1.ConstraintType
	(CursorType)(0),                    // 3: datapower.noesis.v1.CursorType
	(Op)(0),                            // 4: datapower.noesis.v1.Op
	(NullValue)(0),                     // 5: datapower.noesis.v1.NullValue
	(Direction)(0),                     // 6: datapower.noesis.v1.Direction
	(ConsistencyMode)(0),               // 7: datapower.noesis.v1.ConsistencyMode
	(TraversalDirection)(0),            // 8: datapower.noesis.v1.TraversalDirection
	(*DiscoverRequest)(nil),            // 9: datapower.noesis.v1.DiscoverRequest
	(*DiscoverResponse)(nil),           // 10: datapower.noesis.v1.DiscoverResponse
	(*PlatformInfo)(nil),               // 11: datapower.noesis.v1.PlatformInfo
	(*EntityDescriptor)(nil),           // 12: datapower.noesis.v1.EntityDescriptor
	(*FieldDescriptor)(nil),            // 13: datapower.noesis.v1.FieldDescriptor
	(*ConstraintDescriptor)(nil),       // 14: datapower.noesis.v1.ConstraintDescriptor
	(*IndexDescriptor)(nil),            // 15: datapower.noesis.v1.IndexDescriptor
	(*StructuredSchemaDescriptor)(nil), // 16: datapower.noesis.v1.StructuredSchemaDescriptor
	(*UniqueKey)(nil),                  // 17: datapower.noesis.v1.UniqueKey
	(*LinkEndpoint)(nil),               // 18: datapower.noesis.v1.LinkEndpoint
	(*CursorField)(nil),                // 19: datapower.noesis.v1.CursorField
	(*ExtractionCapabilities)(nil),     // 20: datapower.noesis.v1.ExtractionCapabilities
	(*CheckRequest)(nil),               // 21: datapower.noesis.v1.CheckRequest
	(*CheckResponse)(nil),              // 22: datapower.noesis.v1.CheckResponse
	(*OpenRequest)(nil),                // 23: datapower.noesis.v1.OpenRequest
	(*OpenResponse)(nil),               // 24: datapower.noesis.v1.OpenResponse
	(*CloseRequest)(nil),               // 25: datapower.noesis.v1.CloseRequest
	(*CloseResponse)(nil),              // 26: datapower.noesis.v1.CloseResponse
	(*PlanExtractionRequest)(nil),      // 27: datapower.noesis.v1.PlanExtractionRequest
	(*PlanExtractionResponse)(nil),     // 28: datapower.noesis.v1.PlanExtractionResponse
	(*ExtractionSplit)(nil),            // 29: datapower.noesis.v1.ExtractionSplit
	(*ReadSplitRequest)(nil),           // 30: datapower.noesis.v1.ReadSplitRequest
	(*ReadRequest)(nil),                // 31: datapower.noesis.v1.ReadRequest
	(*FullTableScan)(nil),              // 32: datapower.noesis.v1.FullTableScan
	(*ChangeStream)(nil),               // 33: datapower.noesis.v1.ChangeStream
	(*SubgraphRead)(nil),               // 34: datapower.noesis.v1.SubgraphRead
	(*Head)(nil),                       // 35: datapower.noesis.v1.Head
	(*ReadMessage)(nil),                // 36: datapower.noesis.v1.ReadMessage
	(*RecordMsg)(nil),                  // 37: datapower.noesis.v1.RecordMsg
	(*Row)(nil),                        // 38: datapower.noesis.v1.Row
	(*Value)(nil),                      // 39: datapower.noesis.v1.Value
	(*StructValue)(nil),                // 40: datapower.noesis.v1.StructValue
	(*ListValue)(nil),                  // 41: datapower.noesis.v1.ListValue
	(*MapValue)(nil),                   // 42: datapower.noesis.v1.MapValue
	(*StateMsg)(nil),                   // 43: datapower.noesis.v1.StateMsg
	(*Projection)(nil),                 // 44: datapower.noesis.v1.Projection
	(*Filter)(nil),                     // 45: datapower.noesis.v1.Filter
	(*Predicate)(nil),                  // 46: datapower.noesis.v1.Predicate
	(*Ordering)(nil),                   // 47: datapower.noesis.v1.Ordering
	(*OrderBy)(nil),                    // 48: datapower.noesis.v1.OrderBy
	(*SnapshotOptions)(nil),            // 49: datapower.noesis.v1.SnapshotOptions
	(*Cursor)(nil),                     // 50: datapower.noesis.v1.Cursor
	(*RateLimit)(nil),                  // 51: datapower.noesis.v1.RateLimit
	(*Traversal)(nil),                  // 52: datapower.noesis.v1.Traversal
	(*SchemaMsg)(nil),                  // 53: datapower.noesis.v1.SchemaMsg
	(*LogMsg)(nil),                     // 54: datapower.noesis.v1.LogMsg
	(*MetricMsg)(nil),                  // 55: datapower.noesis.v1.MetricMsg
	nil,                                // 56: datapower.noesis.v1.PlatformInfo.TagsEntry
	nil,                                // 57: datapower.noesis.v1.FieldDescriptor.AttributesEntry
	nil,                                // 58: datapower.noesis.v1.ConstraintDescriptor.AttributesEntry
	nil,                                // 59: datapower.noesis.v1.IndexDescriptor.AttributesEntry
	nil,                                // 60: datapower.noesis.v1.StructuredSchemaDescriptor.AttributesEntry
	nil,                                // 61: datapower.noesis.v1.CheckRequest.ConfigEntry
	nil,                                // 62: datapower.noesis.v1.CheckResponse.DetailsEntry
	nil,                                // 63: datapower.noesis.v1.OpenRequest.ConfigEntry
	nil,                                // 64: datapower.noesis.v1.PlanExtractionRequest.ConfigEntry
	nil,                                // 65: datapower.noesis.v1.ExtractionSplit.MetadataEntry
	nil,                                // 66: datapower.noesis.v1.Row.ColumnsEntry
	nil,                                // 67: datapower.noesis.v1.StructValue.FieldsEntry
	nil,                                // 68: datapower.noesis.v1.MapValue.EntriesEntry
	nil,                                // 69: datapower.noesis.v1.LogMsg.KvEntry
	nil,                                // 70: datapower.noesis.v1.MetricMsg.TagsEntry
}
var file_datapower_noesis_v1_connector_proto_depIdxs = []int32{
	11, // 0: datapower.noesis.v1.DiscoverResponse.platform:type_name -> datapower.noesis.v1.PlatformInfo
	12, // 1: datapower.noesis.v1.DiscoverResponse.entities:type_name -> datapower.noesis.v1.EntityDescriptor
	56, // 2: datapower.noesis.v1.PlatformInfo.tags:type_name -> datapower.noesis.v1.PlatformInfo.TagsEntry
	0,  // 3: datapower.noesis.v1.EntityDescriptor.kind:type_name -> datapower.noesis.v1.EntityKind
	16, // 4: datapower.noesis.v1.EntityDescriptor.schema:type_name -> datapower.noesis.v1.StructuredSchemaDescriptor
	17, // 5: datapower.noesis.v1.EntityDescriptor.unique_keys:type_name -> datapower.noesis.v1.UniqueKey
	18, // 6: datapower.noesis.v1.EntityDescriptor.src:type_name -> datapower.noesis.v1.LinkEndpoint
	18, // 7: datapower.noesis.v1.EntityDescriptor.dst:type_name -> datapower.noesis.v1.LinkEndpoint
	19, // 8: datapower.noesis.v1.EntityDescriptor.cursors:type_name -> datapower.noesis.v1.CursorField
	20, // 9: datapower.noesis.v1.EntityDescriptor.capabilities:type_name -> datapower.noesis.v1.ExtractionCapabilities
	1,  // 10: datapower.noesis.v1.FieldDescriptor.type:type_name -> datapower.noesis.v1.FieldType
	1,  // 11: datapower.noesis.v1.FieldDescriptor.array_element_type:type_name -> datapower.noesis.v1.FieldType
	57, // 12: datapower.noesis.v1.FieldDescriptor.attributes:type_name -> datapower.noesis.v1.FieldDescriptor.AttributesEntry
	2,  // 13: datapower.noesis.v1.ConstraintDescriptor.type:type_name -> datapower.noesis.v1.ConstraintType
	58, // 14: datapower.noesis.v1.ConstraintDescriptor.attributes:type_name -> datapower.noesis.v1.ConstraintDescriptor.AttributesEntry
	59, // 15: datapower.noesis.v1.IndexDescriptor.attributes:type_name -> datapower.noesis.v1.IndexDescriptor.AttributesEntry
	13, // 16: datapower.noesis.v1.StructuredSchemaDescriptor.fields:type_name -> datapower.noesis.v1.FieldDescriptor
	14, // 17: datapower.noesis.v1.StructuredSchemaDescriptor.constraints:type_name -> datapower.noesis.v1.ConstraintDescriptor
	15, // 18: datapower.noesis.v1.StructuredSchemaDescriptor.indexes:type_name -> datapower.noesis.v1.IndexDescriptor
	60, // 19: datapower.noesis.v1.StructuredSchemaDescriptor.attributes:type_name -> datapower.noesis.v1.StructuredSchemaDescriptor.AttributesEntry
	3,  // 20: datapower.noesis.v1.CursorField.type:type_name -> datapower.noesis.v1.CursorType
	61, // 21: datapower.noesis.v1.CheckRequest.config:type_name -> datapower.noesis.v1.CheckRequest.ConfigEntry
	62, // 22: datapower.noesis.v1.CheckResponse.details:type_name -> datapower.noesis.v1.CheckResponse.DetailsEntry
	63, // 23: datapower.noesis.v1.OpenRequest.config:type_name -> datapower.noesis.v1.OpenRequest.ConfigEntry
	64, // 24: datapower.noesis.v1.PlanExtractionRequest.config:type_name -> datapower.noesis.v1.PlanExtractionRequest.ConfigEntry
	45, // 25: datapower.noesis.v1.PlanExtractionRequest.filter:type_name -> datapower.noesis.v1.Filter
	49, // 26: datapower.noesis.v1.PlanExtractionRequest.snapshot:type_name -> datapower.noesis.v1.SnapshotOptions
	29, // 27: datapower.noesis.v1.PlanExtractionResponse.splits:type_name -> datapower.noesis.v1.ExtractionSplit
	65, // 28: datapower.noesis.v1.ExtractionSplit.metadata:type_name -> datapower.noesis.v1.ExtractionSplit.MetadataEntry
	29, // 29: datapower.noesis.v1.ReadSplitRequest.split:type_name -> datapower.noesis.v1.ExtractionSplit
	44, // 30: datapower.noesis.v1.ReadSplitRequest.projection:type_name -> datapower.noesis.v1.Projection
	51, // 31: datapower.noesis.v1.ReadSplitRequest.rate_limit:type_name -> datapower.noesis.v1.RateLimit
	32, // 32: datapower.noesis.v1.ReadRequest.full_table:type_name -> datapower.noesis.v1.FullTableScan
	33, // 33: datapower.noesis.v1.ReadRequest.change_stream:type_name -> datapower.noesis.v1.ChangeStream
	34, // 34: datapower.noesis.v1.ReadRequest.subgraph:type_name -> datapower.noesis.v1.SubgraphRead
	44, // 35: datapower.noesis.v1.ReadRequest.projection:type_name -> datapower.noesis.v1.Projection
	51, // 36: datapower.noesis.v1.ReadRequest.rate_limit:type_name -> datapower.noesis.v1.RateLimit
	50, // 37: datapower.noesis.v1.FullTableScan.resume_from:type_name -> datapower.noesis.v1.Cursor
	45, // 38: datapower.noesis.v1.FullTableScan.filter:type_name -> datapower.noesis.v1.Filter
	47, // 39: datapower.noesis.v1.FullTableScan.ordering:type_name -> datapower.noesis.v1.Ordering
	49, // 40: datapower.noesis.v1.FullTableScan.snapshot:type_name -> datapower.noesis.v1.SnapshotOptions
	50, // 41: datapower.noesis.v1.ChangeStream.from:type_name -> datapower.noesis.v1.Cursor
	45, // 42: datapower.noesis.v1.ChangeStream.filter:type_name -> datapower.noesis.v1.Filter
	35, // 43: datapower.noesis.v1.SubgraphRead.heads:type_name -> datapower.noesis.v1.Head
	52, // 44: datapower.noesis.v1.SubgraphRead.traversal:type_name -> datapower.noesis.v1.Traversal
	49, // 45: datapower.noesis.v1.SubgraphRead.snapshot:type_name -> datapower.noesis.v1.SnapshotOptions
	50, // 46: datapower.noesis.v1.SubgraphRead.resume_from:type_name -> datapower.noesis.v1.Cursor
	53, // 47: datapower.noesis.v1.ReadMessage.schema:type_name -> datapower.noesis.v1.SchemaMsg
	37, // 48: datapower.noesis.v1.ReadMessage.record:type_name -> datapower.noesis.v1.RecordMsg
	43, // 49: datapower.noesis.v1.ReadMessage.state:type_name -> datapower.noesis.v1.StateMsg
	54, // 50: datapower.noesis.v1.ReadMessage.log:type_name -> datapower.noesis.v1.LogMsg
	55, // 51: datapower.noesis.v1.ReadMessage.metric:type_name -> datapower.noesis.v1.MetricMsg
	38, // 52: datapower.noesis.v1.RecordMsg.data:type_name -> datapower.noesis.v1.Row
	4,  // 53: datapower.noesis.v1.RecordMsg.op:type_name -> datapower.noesis.v1.Op
	66, // 54: datapower.noesis.v1.Row.columns:type_name -> datapower.noesis.v1.Row.ColumnsEntry
	5,  // 55: datapower.noesis.v1.Value.null_val:type_name -> datapower.noesis.v1.NullValue
	40, // 56: datapower.noesis.v1.Value.struct_val:type_name -> datapower.noesis.v1.StructValue
	41, // 57: datapower.noesis.v1.Value.list_val:type_name -> datapower.noesis.v1.ListValue
	42, // 58: datapower.noesis.v1.Value.map_val:type_name -> datapower.noesis.v1.MapValue
	67, // 59: datapower.noesis.v1.StructValue.fields:type_name -> datapower.noesis.v1.StructValue.FieldsEntry
	39, // 60: datapower.noesis.v1.ListValue.elements:type_name -> datapower.noesis.v1.Value
	68, // 61: datapower.noesis.v1.MapValue.entries:type_name -> datapower.noesis.v1.MapValue.EntriesEntry
	50, // 62: datapower.noesis.v1.StateMsg.cursor:type_name -> datapower.noesis.v1.Cursor
	46, // 63: datapower.noesis.v1.Filter.predicates:type_name -> datapower.noesis.v1.Predicate
	48, // 64: datapower.noesis.v1.Ordering.by:type_name -> datapower.noesis.v1.OrderBy
	6,  // 65: datapower.noesis.v1.OrderBy.direction:type_name -> datapower.noesis.v1.Direction
	7,  // 66: datapower.noesis.v1.SnapshotOptions.mode:type_name -> datapower.noesis.v1.ConsistencyMode
	8,  // 67: datapower.noesis.v1.Traversal.direction:type_name -> datapower.noesis.v1.TraversalDirection
	16, // 68: datapower.noesis.v1.SchemaMsg.schema:type_name -> datapower.noesis.v1.StructuredSchemaDescriptor
	69, // 69: datapower.noesis.v1.LogMsg.kv:type_name -> datapower.noesis.v1.LogMsg.KvEntry
	70, // 70: datapower.noesis.v1.MetricMsg.tags:type_name -> datapower.noesis.v1.MetricMsg.TagsEntry
	39, // 71: datapower.noesis.v1.Row.ColumnsEntry.value:type_name -> datapower.noesis.v1.Value
	39, // 72: datapower.noesis.v1.StructValue.FieldsEntry.value:type_name -> datapower.noesis.v1.Value
	39, // 73: datapower.noesis.v1.MapValue.EntriesEntry.value:type_name -> datapower.noesis.v1.Value
	21, // 74: datapower.noesis.v1.Connector.Check:input_type -> datapower.noesis.v1.CheckRequest
	9,  // 75: datapower.noesis.v1.Connector.Discover:input_type -> datapower.noesis.v1.DiscoverRequest
	27, // 76: datapower.noesis.v1.Connector.PlanExtraction:input_type -> datapower.noesis.v1.PlanExtractionRequest
	23, // 77: datapower.noesis.v1.Connector.Open:input_type -> datapower.noesis.v1.OpenRequest
	31, // 78: datapower.noesis.v1.Connector.Read:input_type -> datapower.noesis.v1.ReadRequest
	30, // 79: datapower.noesis.v1.Connector.ReadSplit:input_type -> datapower.noesis.v1.ReadSplitRequest
	25, // 80: datapower.noesis.v1.Connector.Close:input_type -> datapower.noesis.v1.CloseRequest
	22, // 81: datapower.noesis.v1.Connector.Check:output_type -> datapower.noesis.v1.CheckResponse
	10, // 82: datapower.noesis.v1.Connector.Discover:output_type -> datapower.noesis.v1.DiscoverResponse
	28, // 83: datapower.noesis.v1.Connector.PlanExtraction:output_type -> datapower.noesis.v1.PlanExtractionResponse
	24, // 84: datapower.noesis.v1.Connector.Open:output_type -> datapower.noesis.v1.OpenResponse
	36, // 85: datapower.noesis.v1.Connector.Read:output_type -> datapower.noesis.v1.ReadMessage
	36, // 86: datapower.noesis.v1.Connector.ReadSplit:output_type -> datapower.noesis.v1.ReadMessage
	26, // 87: datapower.noesis.v1.Connector.Close:output_type -> datapower.noesis.v1.CloseResponse
	81, // [81:88] is the sub-list for method output_type
	74, // [74:81] is the sub-list for method input_type
	74, // [74:74] is the sub-list for extension type_name
	74, // [74:74] is the sub-list for extension extendee
	0,  // [0:74] is the sub-list for field type_name
}

func init() { file_datapower_noesis_v1_connector_proto_init() }
func file_datapower_noesis_v1_connector_proto_init() {
	if File_datapower_noesis_v1_connector_proto != nil {
		return
	}
	file_datapower_noesis_v1_connector_proto_msgTypes[22].OneofWrappers = []any{
		(*ReadRequest_FullTable)(nil),
		(*ReadRequest_ChangeStream)(nil),
		(*ReadRequest_Subgraph)(nil),
	}
	file_datapower_noesis_v1_connector_proto_msgTypes[27].OneofWrappers = []any{
		(*ReadMessage_Schema)(nil),
		(*ReadMessage_Record)(nil),
		(*ReadMessage_State)(nil),
		(*ReadMessage_Log)(nil),
		(*ReadMessage_Metric)(nil),
	}
	file_datapower_noesis_v1_connector_proto_msgTypes[30].OneofWrappers = []any{
		(*Value_StringVal)(nil),
		(*Value_Int64Val)(nil),
		(*Value_Int32Val)(nil),
		(*Value_DoubleVal)(nil),
		(*Value_FloatVal)(nil),
		(*Value_BoolVal)(nil),
		(*Value_BytesVal)(nil),
		(*Value_TimestampMicros)(nil),
		(*Value_DateDays)(nil),
		(*Value_TimeMicros)(nil),
		(*Value_NullVal)(nil),
		(*Value_StructVal)(nil),
		(*Value_ListVal)(nil),
		(*Value_MapVal)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_datapower_noesis_v1_connector_proto_rawDesc), len(file_datapower_noesis_v1_connector_proto_rawDesc)),
			NumEnums:      9,
			NumMessages:   62,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_datapower_noesis_v1_connector_proto_goTypes,
		DependencyIndexes: file_datapower_noesis_v1_connector_proto_depIdxs,
		EnumInfos:         file_datapower_noesis_v1_connector_proto_enumTypes,
		MessageInfos:      file_datapower_noesis_v1_connector_proto_msgTypes,
	}.Build()
	File_datapower_noesis_v1_connector_proto = out.File
	file_datapower_noesis_v1_connector_proto_goTypes = nil
	file_datapower_noesis_v1_connector_proto_depIdxs = nil
}
