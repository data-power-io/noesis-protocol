// Sidecar API (gRPC) â€” Storage Writer Service
// ------------------------------------------
// Goal:
// - Provide a lightweight service that runs alongside connectors in the same pod
// - Receives streaming data from connectors over localhost
// - Writes data to storage formats (Parquet, Iceberg, Delta Lake, etc.)
// - Uploads completed files to object storage
//
// Usage:
// - Connector extracts data and streams it to sidecar via StreamData RPC
// - Sidecar buffers data, writes to configured format, and uploads to S3/GCS/etc.
// - Sidecar notifies connector when upload is complete
//
// Benefits:
// - Separation of concerns: connector focuses on extraction, sidecar handles serialization
// - Storage-agnostic: connector doesn't need to know about Parquet, Iceberg, etc.
// - Reusable: same sidecar can work with any connector
// - Efficient: streaming reduces memory footprint

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: datapower/noesis/v1/sidecar.proto

package noesisv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type StorageType int32

const (
	StorageType_STORAGE_TYPE_UNSPECIFIED StorageType = 0
	StorageType_S3                       StorageType = 1
	StorageType_GCS                      StorageType = 2
	StorageType_AZURE_BLOB               StorageType = 3
	StorageType_MINIO                    StorageType = 4
)

// Enum value maps for StorageType.
var (
	StorageType_name = map[int32]string{
		0: "STORAGE_TYPE_UNSPECIFIED",
		1: "S3",
		2: "GCS",
		3: "AZURE_BLOB",
		4: "MINIO",
	}
	StorageType_value = map[string]int32{
		"STORAGE_TYPE_UNSPECIFIED": 0,
		"S3":                       1,
		"GCS":                      2,
		"AZURE_BLOB":               3,
		"MINIO":                    4,
	}
)

func (x StorageType) Enum() *StorageType {
	p := new(StorageType)
	*p = x
	return p
}

func (x StorageType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StorageType) Descriptor() protoreflect.EnumDescriptor {
	return file_datapower_noesis_v1_sidecar_proto_enumTypes[0].Descriptor()
}

func (StorageType) Type() protoreflect.EnumType {
	return &file_datapower_noesis_v1_sidecar_proto_enumTypes[0]
}

func (x StorageType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StorageType.Descriptor instead.
func (StorageType) EnumDescriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{0}
}

type WriteMode int32

const (
	WriteMode_WRITE_MODE_UNSPECIFIED WriteMode = 0
	WriteMode_APPEND                 WriteMode = 1 // Append new data
	WriteMode_MERGE                  WriteMode = 2 // Merge/upsert based on RecordMsg.op (CDC mode)
	WriteMode_OVERWRITE              WriteMode = 3 // Replace all data (batch mode)
)

// Enum value maps for WriteMode.
var (
	WriteMode_name = map[int32]string{
		0: "WRITE_MODE_UNSPECIFIED",
		1: "APPEND",
		2: "MERGE",
		3: "OVERWRITE",
	}
	WriteMode_value = map[string]int32{
		"WRITE_MODE_UNSPECIFIED": 0,
		"APPEND":                 1,
		"MERGE":                  2,
		"OVERWRITE":              3,
	}
)

func (x WriteMode) Enum() *WriteMode {
	p := new(WriteMode)
	*p = x
	return p
}

func (x WriteMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WriteMode) Descriptor() protoreflect.EnumDescriptor {
	return file_datapower_noesis_v1_sidecar_proto_enumTypes[1].Descriptor()
}

func (WriteMode) Type() protoreflect.EnumType {
	return &file_datapower_noesis_v1_sidecar_proto_enumTypes[1]
}

func (x WriteMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use WriteMode.Descriptor instead.
func (WriteMode) EnumDescriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{1}
}

type CompressionCodec int32

const (
	CompressionCodec_COMPRESSION_UNSPECIFIED CompressionCodec = 0
	CompressionCodec_NONE                    CompressionCodec = 1
	CompressionCodec_SNAPPY                  CompressionCodec = 2
	CompressionCodec_GZIP                    CompressionCodec = 3
	CompressionCodec_LZ4                     CompressionCodec = 4
	CompressionCodec_ZSTD                    CompressionCodec = 5
)

// Enum value maps for CompressionCodec.
var (
	CompressionCodec_name = map[int32]string{
		0: "COMPRESSION_UNSPECIFIED",
		1: "NONE",
		2: "SNAPPY",
		3: "GZIP",
		4: "LZ4",
		5: "ZSTD",
	}
	CompressionCodec_value = map[string]int32{
		"COMPRESSION_UNSPECIFIED": 0,
		"NONE":                    1,
		"SNAPPY":                  2,
		"GZIP":                    3,
		"LZ4":                     4,
		"ZSTD":                    5,
	}
)

func (x CompressionCodec) Enum() *CompressionCodec {
	p := new(CompressionCodec)
	*p = x
	return p
}

func (x CompressionCodec) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CompressionCodec) Descriptor() protoreflect.EnumDescriptor {
	return file_datapower_noesis_v1_sidecar_proto_enumTypes[2].Descriptor()
}

func (CompressionCodec) Type() protoreflect.EnumType {
	return &file_datapower_noesis_v1_sidecar_proto_enumTypes[2]
}

func (x CompressionCodec) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CompressionCodec.Descriptor instead.
func (CompressionCodec) EnumDescriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{2}
}

type SessionState int32

const (
	SessionState_SESSION_STATE_UNSPECIFIED SessionState = 0
	SessionState_INITIALIZING              SessionState = 1
	SessionState_WRITING                   SessionState = 2
	SessionState_UPLOADING                 SessionState = 3
	SessionState_FINALIZED                 SessionState = 4
	SessionState_ERROR                     SessionState = 5
)

// Enum value maps for SessionState.
var (
	SessionState_name = map[int32]string{
		0: "SESSION_STATE_UNSPECIFIED",
		1: "INITIALIZING",
		2: "WRITING",
		3: "UPLOADING",
		4: "FINALIZED",
		5: "ERROR",
	}
	SessionState_value = map[string]int32{
		"SESSION_STATE_UNSPECIFIED": 0,
		"INITIALIZING":              1,
		"WRITING":                   2,
		"UPLOADING":                 3,
		"FINALIZED":                 4,
		"ERROR":                     5,
	}
)

func (x SessionState) Enum() *SessionState {
	p := new(SessionState)
	*p = x
	return p
}

func (x SessionState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SessionState) Descriptor() protoreflect.EnumDescriptor {
	return file_datapower_noesis_v1_sidecar_proto_enumTypes[3].Descriptor()
}

func (SessionState) Type() protoreflect.EnumType {
	return &file_datapower_noesis_v1_sidecar_proto_enumTypes[3]
}

func (x SessionState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SessionState.Descriptor instead.
func (SessionState) EnumDescriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{3}
}

type InitSessionRequest struct {
	state     protoimpl.MessageState      `protogen:"open.v1"`
	SessionId string                      `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"` // Unique session identifier
	Entity    string                      `protobuf:"bytes,2,opt,name=entity,proto3" json:"entity,omitempty"`                        // Entity being extracted (e.g., "customers")
	Schema    *StructuredSchemaDescriptor `protobuf:"bytes,3,opt,name=schema,proto3" json:"schema,omitempty"`                        // Schema for the data
	Storage   *StorageConfig              `protobuf:"bytes,4,opt,name=storage,proto3" json:"storage,omitempty"`                      // Where to upload files (S3, GCS, etc.)
	// Storage format configuration (choose one)
	//
	// Types that are valid to be assigned to FormatConfig:
	//
	//	*InitSessionRequest_ParquetConfig
	//	*InitSessionRequest_IcebergConfig
	//	*InitSessionRequest_DeltaConfig
	FormatConfig  isInitSessionRequest_FormatConfig `protobuf_oneof:"format_config"`
	SplitId       string                            `protobuf:"bytes,6,opt,name=split_id,json=splitId,proto3" json:"split_id,omitempty"` // Optional: split identifier for this extraction
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InitSessionRequest) Reset() {
	*x = InitSessionRequest{}
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitSessionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitSessionRequest) ProtoMessage() {}

func (x *InitSessionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitSessionRequest.ProtoReflect.Descriptor instead.
func (*InitSessionRequest) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{0}
}

func (x *InitSessionRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *InitSessionRequest) GetEntity() string {
	if x != nil {
		return x.Entity
	}
	return ""
}

func (x *InitSessionRequest) GetSchema() *StructuredSchemaDescriptor {
	if x != nil {
		return x.Schema
	}
	return nil
}

func (x *InitSessionRequest) GetStorage() *StorageConfig {
	if x != nil {
		return x.Storage
	}
	return nil
}

func (x *InitSessionRequest) GetFormatConfig() isInitSessionRequest_FormatConfig {
	if x != nil {
		return x.FormatConfig
	}
	return nil
}

func (x *InitSessionRequest) GetParquetConfig() *ParquetConfig {
	if x != nil {
		if x, ok := x.FormatConfig.(*InitSessionRequest_ParquetConfig); ok {
			return x.ParquetConfig
		}
	}
	return nil
}

func (x *InitSessionRequest) GetIcebergConfig() *IcebergConfig {
	if x != nil {
		if x, ok := x.FormatConfig.(*InitSessionRequest_IcebergConfig); ok {
			return x.IcebergConfig
		}
	}
	return nil
}

func (x *InitSessionRequest) GetDeltaConfig() *DeltaConfig {
	if x != nil {
		if x, ok := x.FormatConfig.(*InitSessionRequest_DeltaConfig); ok {
			return x.DeltaConfig
		}
	}
	return nil
}

func (x *InitSessionRequest) GetSplitId() string {
	if x != nil {
		return x.SplitId
	}
	return ""
}

type isInitSessionRequest_FormatConfig interface {
	isInitSessionRequest_FormatConfig()
}

type InitSessionRequest_ParquetConfig struct {
	ParquetConfig *ParquetConfig `protobuf:"bytes,5,opt,name=parquet_config,json=parquetConfig,proto3,oneof"` // Parquet file settings
}

type InitSessionRequest_IcebergConfig struct {
	IcebergConfig *IcebergConfig `protobuf:"bytes,7,opt,name=iceberg_config,json=icebergConfig,proto3,oneof"` // Iceberg table settings
}

type InitSessionRequest_DeltaConfig struct {
	DeltaConfig *DeltaConfig `protobuf:"bytes,8,opt,name=delta_config,json=deltaConfig,proto3,oneof"` // Delta Lake table settings
}

func (*InitSessionRequest_ParquetConfig) isInitSessionRequest_FormatConfig() {}

func (*InitSessionRequest_IcebergConfig) isInitSessionRequest_FormatConfig() {}

func (*InitSessionRequest_DeltaConfig) isInitSessionRequest_FormatConfig() {}

type StorageConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          StorageType            `protobuf:"varint,1,opt,name=type,proto3,enum=datapower.noesis.v1.StorageType" json:"type,omitempty"`                                                   // S3, GCS, MinIO, etc.
	Bucket        string                 `protobuf:"bytes,2,opt,name=bucket,proto3" json:"bucket,omitempty"`                                                                                     // Bucket/container name
	PathPrefix    string                 `protobuf:"bytes,3,opt,name=path_prefix,json=pathPrefix,proto3" json:"path_prefix,omitempty"`                                                           // Path prefix for uploaded files (e.g., "staging/customers/run-123/")
	Credentials   map[string]string      `protobuf:"bytes,4,rep,name=credentials,proto3" json:"credentials,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Storage credentials (access keys, service account, etc.)
	Endpoint      string                 `protobuf:"bytes,5,opt,name=endpoint,proto3" json:"endpoint,omitempty"`                                                                                 // Optional: custom endpoint (for MinIO, etc.)
	UseSsl        bool                   `protobuf:"varint,6,opt,name=use_ssl,json=useSsl,proto3" json:"use_ssl,omitempty"`                                                                      // Whether to use SSL/TLS
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StorageConfig) Reset() {
	*x = StorageConfig{}
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageConfig) ProtoMessage() {}

func (x *StorageConfig) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageConfig.ProtoReflect.Descriptor instead.
func (*StorageConfig) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{1}
}

func (x *StorageConfig) GetType() StorageType {
	if x != nil {
		return x.Type
	}
	return StorageType_STORAGE_TYPE_UNSPECIFIED
}

func (x *StorageConfig) GetBucket() string {
	if x != nil {
		return x.Bucket
	}
	return ""
}

func (x *StorageConfig) GetPathPrefix() string {
	if x != nil {
		return x.PathPrefix
	}
	return ""
}

func (x *StorageConfig) GetCredentials() map[string]string {
	if x != nil {
		return x.Credentials
	}
	return nil
}

func (x *StorageConfig) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *StorageConfig) GetUseSsl() bool {
	if x != nil {
		return x.UseSsl
	}
	return false
}

// Parquet format configuration
type ParquetConfig struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Compression      CompressionCodec       `protobuf:"varint,1,opt,name=compression,proto3,enum=datapower.noesis.v1.CompressionCodec" json:"compression,omitempty"`                          // Compression algorithm
	RowGroupSize     int32                  `protobuf:"varint,2,opt,name=row_group_size,json=rowGroupSize,proto3" json:"row_group_size,omitempty"`                                            // Rows per row group (default 100k)
	MaxFileSizeBytes int64                  `protobuf:"varint,3,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`                              // Max file size before rotation (default 128MB)
	PageSize         int32                  `protobuf:"varint,4,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`                                                          // Page size in bytes (default 1MB)
	Metadata         map[string]string      `protobuf:"bytes,5,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Custom file metadata
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ParquetConfig) Reset() {
	*x = ParquetConfig{}
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ParquetConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ParquetConfig) ProtoMessage() {}

func (x *ParquetConfig) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ParquetConfig.ProtoReflect.Descriptor instead.
func (*ParquetConfig) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{2}
}

func (x *ParquetConfig) GetCompression() CompressionCodec {
	if x != nil {
		return x.Compression
	}
	return CompressionCodec_COMPRESSION_UNSPECIFIED
}

func (x *ParquetConfig) GetRowGroupSize() int32 {
	if x != nil {
		return x.RowGroupSize
	}
	return 0
}

func (x *ParquetConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

func (x *ParquetConfig) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *ParquetConfig) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// Iceberg format configuration
type IcebergConfig struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	TableName           string                 `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`                                                                                             // Iceberg table name (catalog.namespace.table)
	WriteMode           WriteMode              `protobuf:"varint,2,opt,name=write_mode,json=writeMode,proto3,enum=datapower.noesis.v1.WriteMode" json:"write_mode,omitempty"`                                                         // APPEND, MERGE, OVERWRITE
	Compression         CompressionCodec       `protobuf:"varint,3,opt,name=compression,proto3,enum=datapower.noesis.v1.CompressionCodec" json:"compression,omitempty"`                                                               // Compression algorithm
	TargetFileSizeBytes int64                  `protobuf:"varint,4,opt,name=target_file_size_bytes,json=targetFileSizeBytes,proto3" json:"target_file_size_bytes,omitempty"`                                                          // Target data file size (default 128MB)
	TableProperties     map[string]string      `protobuf:"bytes,5,rep,name=table_properties,json=tableProperties,proto3" json:"table_properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Iceberg table properties
	CatalogUri          string                 `protobuf:"bytes,6,opt,name=catalog_uri,json=catalogUri,proto3" json:"catalog_uri,omitempty"`                                                                                          // Iceberg catalog URI (e.g., Hive metastore, Glue, REST)
	WarehouseLocation   string                 `protobuf:"bytes,7,opt,name=warehouse_location,json=warehouseLocation,proto3" json:"warehouse_location,omitempty"`                                                                     // Warehouse location (S3/GCS path)
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *IcebergConfig) Reset() {
	*x = IcebergConfig{}
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IcebergConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IcebergConfig) ProtoMessage() {}

func (x *IcebergConfig) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IcebergConfig.ProtoReflect.Descriptor instead.
func (*IcebergConfig) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{3}
}

func (x *IcebergConfig) GetTableName() string {
	if x != nil {
		return x.TableName
	}
	return ""
}

func (x *IcebergConfig) GetWriteMode() WriteMode {
	if x != nil {
		return x.WriteMode
	}
	return WriteMode_WRITE_MODE_UNSPECIFIED
}

func (x *IcebergConfig) GetCompression() CompressionCodec {
	if x != nil {
		return x.Compression
	}
	return CompressionCodec_COMPRESSION_UNSPECIFIED
}

func (x *IcebergConfig) GetTargetFileSizeBytes() int64 {
	if x != nil {
		return x.TargetFileSizeBytes
	}
	return 0
}

func (x *IcebergConfig) GetTableProperties() map[string]string {
	if x != nil {
		return x.TableProperties
	}
	return nil
}

func (x *IcebergConfig) GetCatalogUri() string {
	if x != nil {
		return x.CatalogUri
	}
	return ""
}

func (x *IcebergConfig) GetWarehouseLocation() string {
	if x != nil {
		return x.WarehouseLocation
	}
	return ""
}

// Delta Lake format configuration
type DeltaConfig struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	TablePath           string                 `protobuf:"bytes,1,opt,name=table_path,json=tablePath,proto3" json:"table_path,omitempty"`                                                                                             // Delta table path (S3/GCS/HDFS path)
	WriteMode           WriteMode              `protobuf:"varint,2,opt,name=write_mode,json=writeMode,proto3,enum=datapower.noesis.v1.WriteMode" json:"write_mode,omitempty"`                                                         // APPEND, MERGE, OVERWRITE
	Compression         CompressionCodec       `protobuf:"varint,3,opt,name=compression,proto3,enum=datapower.noesis.v1.CompressionCodec" json:"compression,omitempty"`                                                               // Compression algorithm
	TargetFileSizeBytes int64                  `protobuf:"varint,4,opt,name=target_file_size_bytes,json=targetFileSizeBytes,proto3" json:"target_file_size_bytes,omitempty"`                                                          // Target data file size (default 128MB)
	TableProperties     map[string]string      `protobuf:"bytes,5,rep,name=table_properties,json=tableProperties,proto3" json:"table_properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Delta table properties
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *DeltaConfig) Reset() {
	*x = DeltaConfig{}
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeltaConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeltaConfig) ProtoMessage() {}

func (x *DeltaConfig) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeltaConfig.ProtoReflect.Descriptor instead.
func (*DeltaConfig) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{4}
}

func (x *DeltaConfig) GetTablePath() string {
	if x != nil {
		return x.TablePath
	}
	return ""
}

func (x *DeltaConfig) GetWriteMode() WriteMode {
	if x != nil {
		return x.WriteMode
	}
	return WriteMode_WRITE_MODE_UNSPECIFIED
}

func (x *DeltaConfig) GetCompression() CompressionCodec {
	if x != nil {
		return x.Compression
	}
	return CompressionCodec_COMPRESSION_UNSPECIFIED
}

func (x *DeltaConfig) GetTargetFileSizeBytes() int64 {
	if x != nil {
		return x.TargetFileSizeBytes
	}
	return 0
}

func (x *DeltaConfig) GetTableProperties() map[string]string {
	if x != nil {
		return x.TableProperties
	}
	return nil
}

type InitSessionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`                      // Error message if success=false
	SessionId     string                 `protobuf:"bytes,3,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"` // Echo back session ID
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InitSessionResponse) Reset() {
	*x = InitSessionResponse{}
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitSessionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitSessionResponse) ProtoMessage() {}

func (x *InitSessionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitSessionResponse.ProtoReflect.Descriptor instead.
func (*InitSessionResponse) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{5}
}

func (x *InitSessionResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *InitSessionResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *InitSessionResponse) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

// A batch of records to write.
// The connector sends multiple DataBatch messages in a stream.
type DataBatch struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`          // Must match InitSession
	Records       []*RecordMsg           `protobuf:"bytes,2,rep,name=records,proto3" json:"records,omitempty"`                               // Batch of records (reuse RecordMsg from connector.proto)
	BatchSeq      int64                  `protobuf:"varint,3,opt,name=batch_seq,json=batchSeq,proto3" json:"batch_seq,omitempty"`            // Monotonically increasing batch sequence number
	IsLastBatch   bool                   `protobuf:"varint,4,opt,name=is_last_batch,json=isLastBatch,proto3" json:"is_last_batch,omitempty"` // True if this is the final batch in the stream
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataBatch) Reset() {
	*x = DataBatch{}
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataBatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataBatch) ProtoMessage() {}

func (x *DataBatch) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataBatch.ProtoReflect.Descriptor instead.
func (*DataBatch) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{6}
}

func (x *DataBatch) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *DataBatch) GetRecords() []*RecordMsg {
	if x != nil {
		return x.Records
	}
	return nil
}

func (x *DataBatch) GetBatchSeq() int64 {
	if x != nil {
		return x.BatchSeq
	}
	return 0
}

func (x *DataBatch) GetIsLastBatch() bool {
	if x != nil {
		return x.IsLastBatch
	}
	return false
}

type StreamDataResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Success        bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Message        string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`                                      // Error message if success=false
	RecordsWritten int64                  `protobuf:"varint,3,opt,name=records_written,json=recordsWritten,proto3" json:"records_written,omitempty"` // Total records written so far
	BytesWritten   int64                  `protobuf:"varint,4,opt,name=bytes_written,json=bytesWritten,proto3" json:"bytes_written,omitempty"`       // Total bytes written so far
	FilesUploaded  int32                  `protobuf:"varint,5,opt,name=files_uploaded,json=filesUploaded,proto3" json:"files_uploaded,omitempty"`    // Number of data files uploaded so far
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *StreamDataResponse) Reset() {
	*x = StreamDataResponse{}
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamDataResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamDataResponse) ProtoMessage() {}

func (x *StreamDataResponse) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamDataResponse.ProtoReflect.Descriptor instead.
func (*StreamDataResponse) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{7}
}

func (x *StreamDataResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *StreamDataResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *StreamDataResponse) GetRecordsWritten() int64 {
	if x != nil {
		return x.RecordsWritten
	}
	return 0
}

func (x *StreamDataResponse) GetBytesWritten() int64 {
	if x != nil {
		return x.BytesWritten
	}
	return 0
}

func (x *StreamDataResponse) GetFilesUploaded() int32 {
	if x != nil {
		return x.FilesUploaded
	}
	return 0
}

type FinalizeSessionRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	ForceFlush    bool                   `protobuf:"varint,2,opt,name=force_flush,json=forceFlush,proto3" json:"force_flush,omitempty"` // Force flush any buffered data
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FinalizeSessionRequest) Reset() {
	*x = FinalizeSessionRequest{}
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FinalizeSessionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FinalizeSessionRequest) ProtoMessage() {}

func (x *FinalizeSessionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FinalizeSessionRequest.ProtoReflect.Descriptor instead.
func (*FinalizeSessionRequest) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{8}
}

func (x *FinalizeSessionRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *FinalizeSessionRequest) GetForceFlush() bool {
	if x != nil {
		return x.ForceFlush
	}
	return false
}

type FinalizeSessionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Stats         *SessionStats          `protobuf:"bytes,3,opt,name=stats,proto3" json:"stats,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FinalizeSessionResponse) Reset() {
	*x = FinalizeSessionResponse{}
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FinalizeSessionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FinalizeSessionResponse) ProtoMessage() {}

func (x *FinalizeSessionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FinalizeSessionResponse.ProtoReflect.Descriptor instead.
func (*FinalizeSessionResponse) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{9}
}

func (x *FinalizeSessionResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *FinalizeSessionResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *FinalizeSessionResponse) GetStats() *SessionStats {
	if x != nil {
		return x.Stats
	}
	return nil
}

type SessionStats struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	TotalRecordsWritten int64                  `protobuf:"varint,1,opt,name=total_records_written,json=totalRecordsWritten,proto3" json:"total_records_written,omitempty"`
	TotalBytesWritten   int64                  `protobuf:"varint,2,opt,name=total_bytes_written,json=totalBytesWritten,proto3" json:"total_bytes_written,omitempty"`
	TotalFilesUploaded  int32                  `protobuf:"varint,3,opt,name=total_files_uploaded,json=totalFilesUploaded,proto3" json:"total_files_uploaded,omitempty"`
	FilePaths           []string               `protobuf:"bytes,4,rep,name=file_paths,json=filePaths,proto3" json:"file_paths,omitempty"`     // List of uploaded file paths
	DurationMs          int64                  `protobuf:"varint,5,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"` // Total session duration
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *SessionStats) Reset() {
	*x = SessionStats{}
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SessionStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionStats) ProtoMessage() {}

func (x *SessionStats) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionStats.ProtoReflect.Descriptor instead.
func (*SessionStats) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{10}
}

func (x *SessionStats) GetTotalRecordsWritten() int64 {
	if x != nil {
		return x.TotalRecordsWritten
	}
	return 0
}

func (x *SessionStats) GetTotalBytesWritten() int64 {
	if x != nil {
		return x.TotalBytesWritten
	}
	return 0
}

func (x *SessionStats) GetTotalFilesUploaded() int32 {
	if x != nil {
		return x.TotalFilesUploaded
	}
	return 0
}

func (x *SessionStats) GetFilePaths() []string {
	if x != nil {
		return x.FilePaths
	}
	return nil
}

func (x *SessionStats) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

type GetSessionStatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSessionStatusRequest) Reset() {
	*x = GetSessionStatusRequest{}
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSessionStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSessionStatusRequest) ProtoMessage() {}

func (x *GetSessionStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSessionStatusRequest.ProtoReflect.Descriptor instead.
func (*GetSessionStatusRequest) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{11}
}

func (x *GetSessionStatusRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

type GetSessionStatusResponse struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	State              SessionState           `protobuf:"varint,1,opt,name=state,proto3,enum=datapower.noesis.v1.SessionState" json:"state,omitempty"`
	Stats              *SessionStats          `protobuf:"bytes,2,opt,name=stats,proto3" json:"stats,omitempty"`
	CurrentFile        string                 `protobuf:"bytes,3,opt,name=current_file,json=currentFile,proto3" json:"current_file,omitempty"`                         // Currently writing to this file
	CurrentFileRecords int64                  `protobuf:"varint,4,opt,name=current_file_records,json=currentFileRecords,proto3" json:"current_file_records,omitempty"` // Records in current file
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *GetSessionStatusResponse) Reset() {
	*x = GetSessionStatusResponse{}
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSessionStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSessionStatusResponse) ProtoMessage() {}

func (x *GetSessionStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_datapower_noesis_v1_sidecar_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSessionStatusResponse.ProtoReflect.Descriptor instead.
func (*GetSessionStatusResponse) Descriptor() ([]byte, []int) {
	return file_datapower_noesis_v1_sidecar_proto_rawDescGZIP(), []int{12}
}

func (x *GetSessionStatusResponse) GetState() SessionState {
	if x != nil {
		return x.State
	}
	return SessionState_SESSION_STATE_UNSPECIFIED
}

func (x *GetSessionStatusResponse) GetStats() *SessionStats {
	if x != nil {
		return x.Stats
	}
	return nil
}

func (x *GetSessionStatusResponse) GetCurrentFile() string {
	if x != nil {
		return x.CurrentFile
	}
	return ""
}

func (x *GetSessionStatusResponse) GetCurrentFileRecords() int64 {
	if x != nil {
		return x.CurrentFileRecords
	}
	return 0
}

var File_datapower_noesis_v1_sidecar_proto protoreflect.FileDescriptor

const file_datapower_noesis_v1_sidecar_proto_rawDesc = "" +
	"\n" +
	"!datapower/noesis/v1/sidecar.proto\x12\x13datapower.noesis.v1\x1a#datapower/noesis/v1/connector.proto\"\xdf\x03\n" +
	"\x12InitSessionRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x16\n" +
	"\x06entity\x18\x02 \x01(\tR\x06entity\x12G\n" +
	"\x06schema\x18\x03 \x01(\v2/.datapower.noesis.v1.StructuredSchemaDescriptorR\x06schema\x12<\n" +
	"\astorage\x18\x04 \x01(\v2\".datapower.noesis.v1.StorageConfigR\astorage\x12K\n" +
	"\x0eparquet_config\x18\x05 \x01(\v2\".datapower.noesis.v1.ParquetConfigH\x00R\rparquetConfig\x12K\n" +
	"\x0eiceberg_config\x18\a \x01(\v2\".datapower.noesis.v1.IcebergConfigH\x00R\ricebergConfig\x12E\n" +
	"\fdelta_config\x18\b \x01(\v2 .datapower.noesis.v1.DeltaConfigH\x00R\vdeltaConfig\x12\x19\n" +
	"\bsplit_id\x18\x06 \x01(\tR\asplitIdB\x0f\n" +
	"\rformat_config\"\xca\x02\n" +
	"\rStorageConfig\x124\n" +
	"\x04type\x18\x01 \x01(\x0e2 .datapower.noesis.v1.StorageTypeR\x04type\x12\x16\n" +
	"\x06bucket\x18\x02 \x01(\tR\x06bucket\x12\x1f\n" +
	"\vpath_prefix\x18\x03 \x01(\tR\n" +
	"pathPrefix\x12U\n" +
	"\vcredentials\x18\x04 \x03(\v23.datapower.noesis.v1.StorageConfig.CredentialsEntryR\vcredentials\x12\x1a\n" +
	"\bendpoint\x18\x05 \x01(\tR\bendpoint\x12\x17\n" +
	"\ause_ssl\x18\x06 \x01(\bR\x06useSsl\x1a>\n" +
	"\x10CredentialsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xd5\x02\n" +
	"\rParquetConfig\x12G\n" +
	"\vcompression\x18\x01 \x01(\x0e2%.datapower.noesis.v1.CompressionCodecR\vcompression\x12$\n" +
	"\x0erow_group_size\x18\x02 \x01(\x05R\frowGroupSize\x12-\n" +
	"\x13max_file_size_bytes\x18\x03 \x01(\x03R\x10maxFileSizeBytes\x12\x1b\n" +
	"\tpage_size\x18\x04 \x01(\x05R\bpageSize\x12L\n" +
	"\bmetadata\x18\x05 \x03(\v20.datapower.noesis.v1.ParquetConfig.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xe3\x03\n" +
	"\rIcebergConfig\x12\x1d\n" +
	"\n" +
	"table_name\x18\x01 \x01(\tR\ttableName\x12=\n" +
	"\n" +
	"write_mode\x18\x02 \x01(\x0e2\x1e.datapower.noesis.v1.WriteModeR\twriteMode\x12G\n" +
	"\vcompression\x18\x03 \x01(\x0e2%.datapower.noesis.v1.CompressionCodecR\vcompression\x123\n" +
	"\x16target_file_size_bytes\x18\x04 \x01(\x03R\x13targetFileSizeBytes\x12b\n" +
	"\x10table_properties\x18\x05 \x03(\v27.datapower.noesis.v1.IcebergConfig.TablePropertiesEntryR\x0ftableProperties\x12\x1f\n" +
	"\vcatalog_uri\x18\x06 \x01(\tR\n" +
	"catalogUri\x12-\n" +
	"\x12warehouse_location\x18\a \x01(\tR\x11warehouseLocation\x1aB\n" +
	"\x14TablePropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x8f\x03\n" +
	"\vDeltaConfig\x12\x1d\n" +
	"\n" +
	"table_path\x18\x01 \x01(\tR\ttablePath\x12=\n" +
	"\n" +
	"write_mode\x18\x02 \x01(\x0e2\x1e.datapower.noesis.v1.WriteModeR\twriteMode\x12G\n" +
	"\vcompression\x18\x03 \x01(\x0e2%.datapower.noesis.v1.CompressionCodecR\vcompression\x123\n" +
	"\x16target_file_size_bytes\x18\x04 \x01(\x03R\x13targetFileSizeBytes\x12`\n" +
	"\x10table_properties\x18\x05 \x03(\v25.datapower.noesis.v1.DeltaConfig.TablePropertiesEntryR\x0ftableProperties\x1aB\n" +
	"\x14TablePropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"h\n" +
	"\x13InitSessionResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12\x1d\n" +
	"\n" +
	"session_id\x18\x03 \x01(\tR\tsessionId\"\xa5\x01\n" +
	"\tDataBatch\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x128\n" +
	"\arecords\x18\x02 \x03(\v2\x1e.datapower.noesis.v1.RecordMsgR\arecords\x12\x1b\n" +
	"\tbatch_seq\x18\x03 \x01(\x03R\bbatchSeq\x12\"\n" +
	"\ris_last_batch\x18\x04 \x01(\bR\visLastBatch\"\xbd\x01\n" +
	"\x12StreamDataResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12'\n" +
	"\x0frecords_written\x18\x03 \x01(\x03R\x0erecordsWritten\x12#\n" +
	"\rbytes_written\x18\x04 \x01(\x03R\fbytesWritten\x12%\n" +
	"\x0efiles_uploaded\x18\x05 \x01(\x05R\rfilesUploaded\"X\n" +
	"\x16FinalizeSessionRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x1f\n" +
	"\vforce_flush\x18\x02 \x01(\bR\n" +
	"forceFlush\"\x86\x01\n" +
	"\x17FinalizeSessionResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x127\n" +
	"\x05stats\x18\x03 \x01(\v2!.datapower.noesis.v1.SessionStatsR\x05stats\"\xe4\x01\n" +
	"\fSessionStats\x122\n" +
	"\x15total_records_written\x18\x01 \x01(\x03R\x13totalRecordsWritten\x12.\n" +
	"\x13total_bytes_written\x18\x02 \x01(\x03R\x11totalBytesWritten\x120\n" +
	"\x14total_files_uploaded\x18\x03 \x01(\x05R\x12totalFilesUploaded\x12\x1d\n" +
	"\n" +
	"file_paths\x18\x04 \x03(\tR\tfilePaths\x12\x1f\n" +
	"\vduration_ms\x18\x05 \x01(\x03R\n" +
	"durationMs\"8\n" +
	"\x17GetSessionStatusRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\"\xe1\x01\n" +
	"\x18GetSessionStatusResponse\x127\n" +
	"\x05state\x18\x01 \x01(\x0e2!.datapower.noesis.v1.SessionStateR\x05state\x127\n" +
	"\x05stats\x18\x02 \x01(\v2!.datapower.noesis.v1.SessionStatsR\x05stats\x12!\n" +
	"\fcurrent_file\x18\x03 \x01(\tR\vcurrentFile\x120\n" +
	"\x14current_file_records\x18\x04 \x01(\x03R\x12currentFileRecords*W\n" +
	"\vStorageType\x12\x1c\n" +
	"\x18STORAGE_TYPE_UNSPECIFIED\x10\x00\x12\x06\n" +
	"\x02S3\x10\x01\x12\a\n" +
	"\x03GCS\x10\x02\x12\x0e\n" +
	"\n" +
	"AZURE_BLOB\x10\x03\x12\t\n" +
	"\x05MINIO\x10\x04*M\n" +
	"\tWriteMode\x12\x1a\n" +
	"\x16WRITE_MODE_UNSPECIFIED\x10\x00\x12\n" +
	"\n" +
	"\x06APPEND\x10\x01\x12\t\n" +
	"\x05MERGE\x10\x02\x12\r\n" +
	"\tOVERWRITE\x10\x03*b\n" +
	"\x10CompressionCodec\x12\x1b\n" +
	"\x17COMPRESSION_UNSPECIFIED\x10\x00\x12\b\n" +
	"\x04NONE\x10\x01\x12\n" +
	"\n" +
	"\x06SNAPPY\x10\x02\x12\b\n" +
	"\x04GZIP\x10\x03\x12\a\n" +
	"\x03LZ4\x10\x04\x12\b\n" +
	"\x04ZSTD\x10\x05*u\n" +
	"\fSessionState\x12\x1d\n" +
	"\x19SESSION_STATE_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fINITIALIZING\x10\x01\x12\v\n" +
	"\aWRITING\x10\x02\x12\r\n" +
	"\tUPLOADING\x10\x03\x12\r\n" +
	"\tFINALIZED\x10\x04\x12\t\n" +
	"\x05ERROR\x10\x052\xa3\x03\n" +
	"\aSidecar\x12`\n" +
	"\vInitSession\x12'.datapower.noesis.v1.InitSessionRequest\x1a(.datapower.noesis.v1.InitSessionResponse\x12W\n" +
	"\n" +
	"StreamData\x12\x1e.datapower.noesis.v1.DataBatch\x1a'.datapower.noesis.v1.StreamDataResponse(\x01\x12l\n" +
	"\x0fFinalizeSession\x12+.datapower.noesis.v1.FinalizeSessionRequest\x1a,.datapower.noesis.v1.FinalizeSessionResponse\x12o\n" +
	"\x10GetSessionStatus\x12,.datapower.noesis.v1.GetSessionStatusRequest\x1a-.datapower.noesis.v1.GetSessionStatusResponseBk\n" +
	"\x13datapower.noesis.v1P\x01ZRgithub.com/data-power-io/noesis-protocol/languages/go/datapower/noesis/v1;noesisv1b\x06proto3"

var (
	file_datapower_noesis_v1_sidecar_proto_rawDescOnce sync.Once
	file_datapower_noesis_v1_sidecar_proto_rawDescData []byte
)

func file_datapower_noesis_v1_sidecar_proto_rawDescGZIP() []byte {
	file_datapower_noesis_v1_sidecar_proto_rawDescOnce.Do(func() {
		file_datapower_noesis_v1_sidecar_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_datapower_noesis_v1_sidecar_proto_rawDesc), len(file_datapower_noesis_v1_sidecar_proto_rawDesc)))
	})
	return file_datapower_noesis_v1_sidecar_proto_rawDescData
}

var file_datapower_noesis_v1_sidecar_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_datapower_noesis_v1_sidecar_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_datapower_noesis_v1_sidecar_proto_goTypes = []any{
	(StorageType)(0),                   // 0: datapower.noesis.v1.StorageType
	(WriteMode)(0),                     // 1: datapower.noesis.v1.WriteMode
	(CompressionCodec)(0),              // 2: datapower.noesis.v1.CompressionCodec
	(SessionState)(0),                  // 3: datapower.noesis.v1.SessionState
	(*InitSessionRequest)(nil),         // 4: datapower.noesis.v1.InitSessionRequest
	(*StorageConfig)(nil),              // 5: datapower.noesis.v1.StorageConfig
	(*ParquetConfig)(nil),              // 6: datapower.noesis.v1.ParquetConfig
	(*IcebergConfig)(nil),              // 7: datapower.noesis.v1.IcebergConfig
	(*DeltaConfig)(nil),                // 8: datapower.noesis.v1.DeltaConfig
	(*InitSessionResponse)(nil),        // 9: datapower.noesis.v1.InitSessionResponse
	(*DataBatch)(nil),                  // 10: datapower.noesis.v1.DataBatch
	(*StreamDataResponse)(nil),         // 11: datapower.noesis.v1.StreamDataResponse
	(*FinalizeSessionRequest)(nil),     // 12: datapower.noesis.v1.FinalizeSessionRequest
	(*FinalizeSessionResponse)(nil),    // 13: datapower.noesis.v1.FinalizeSessionResponse
	(*SessionStats)(nil),               // 14: datapower.noesis.v1.SessionStats
	(*GetSessionStatusRequest)(nil),    // 15: datapower.noesis.v1.GetSessionStatusRequest
	(*GetSessionStatusResponse)(nil),   // 16: datapower.noesis.v1.GetSessionStatusResponse
	nil,                                // 17: datapower.noesis.v1.StorageConfig.CredentialsEntry
	nil,                                // 18: datapower.noesis.v1.ParquetConfig.MetadataEntry
	nil,                                // 19: datapower.noesis.v1.IcebergConfig.TablePropertiesEntry
	nil,                                // 20: datapower.noesis.v1.DeltaConfig.TablePropertiesEntry
	(*StructuredSchemaDescriptor)(nil), // 21: datapower.noesis.v1.StructuredSchemaDescriptor
	(*RecordMsg)(nil),                  // 22: datapower.noesis.v1.RecordMsg
}
var file_datapower_noesis_v1_sidecar_proto_depIdxs = []int32{
	21, // 0: datapower.noesis.v1.InitSessionRequest.schema:type_name -> datapower.noesis.v1.StructuredSchemaDescriptor
	5,  // 1: datapower.noesis.v1.InitSessionRequest.storage:type_name -> datapower.noesis.v1.StorageConfig
	6,  // 2: datapower.noesis.v1.InitSessionRequest.parquet_config:type_name -> datapower.noesis.v1.ParquetConfig
	7,  // 3: datapower.noesis.v1.InitSessionRequest.iceberg_config:type_name -> datapower.noesis.v1.IcebergConfig
	8,  // 4: datapower.noesis.v1.InitSessionRequest.delta_config:type_name -> datapower.noesis.v1.DeltaConfig
	0,  // 5: datapower.noesis.v1.StorageConfig.type:type_name -> datapower.noesis.v1.StorageType
	17, // 6: datapower.noesis.v1.StorageConfig.credentials:type_name -> datapower.noesis.v1.StorageConfig.CredentialsEntry
	2,  // 7: datapower.noesis.v1.ParquetConfig.compression:type_name -> datapower.noesis.v1.CompressionCodec
	18, // 8: datapower.noesis.v1.ParquetConfig.metadata:type_name -> datapower.noesis.v1.ParquetConfig.MetadataEntry
	1,  // 9: datapower.noesis.v1.IcebergConfig.write_mode:type_name -> datapower.noesis.v1.WriteMode
	2,  // 10: datapower.noesis.v1.IcebergConfig.compression:type_name -> datapower.noesis.v1.CompressionCodec
	19, // 11: datapower.noesis.v1.IcebergConfig.table_properties:type_name -> datapower.noesis.v1.IcebergConfig.TablePropertiesEntry
	1,  // 12: datapower.noesis.v1.DeltaConfig.write_mode:type_name -> datapower.noesis.v1.WriteMode
	2,  // 13: datapower.noesis.v1.DeltaConfig.compression:type_name -> datapower.noesis.v1.CompressionCodec
	20, // 14: datapower.noesis.v1.DeltaConfig.table_properties:type_name -> datapower.noesis.v1.DeltaConfig.TablePropertiesEntry
	22, // 15: datapower.noesis.v1.DataBatch.records:type_name -> datapower.noesis.v1.RecordMsg
	14, // 16: datapower.noesis.v1.FinalizeSessionResponse.stats:type_name -> datapower.noesis.v1.SessionStats
	3,  // 17: datapower.noesis.v1.GetSessionStatusResponse.state:type_name -> datapower.noesis.v1.SessionState
	14, // 18: datapower.noesis.v1.GetSessionStatusResponse.stats:type_name -> datapower.noesis.v1.SessionStats
	4,  // 19: datapower.noesis.v1.Sidecar.InitSession:input_type -> datapower.noesis.v1.InitSessionRequest
	10, // 20: datapower.noesis.v1.Sidecar.StreamData:input_type -> datapower.noesis.v1.DataBatch
	12, // 21: datapower.noesis.v1.Sidecar.FinalizeSession:input_type -> datapower.noesis.v1.FinalizeSessionRequest
	15, // 22: datapower.noesis.v1.Sidecar.GetSessionStatus:input_type -> datapower.noesis.v1.GetSessionStatusRequest
	9,  // 23: datapower.noesis.v1.Sidecar.InitSession:output_type -> datapower.noesis.v1.InitSessionResponse
	11, // 24: datapower.noesis.v1.Sidecar.StreamData:output_type -> datapower.noesis.v1.StreamDataResponse
	13, // 25: datapower.noesis.v1.Sidecar.FinalizeSession:output_type -> datapower.noesis.v1.FinalizeSessionResponse
	16, // 26: datapower.noesis.v1.Sidecar.GetSessionStatus:output_type -> datapower.noesis.v1.GetSessionStatusResponse
	23, // [23:27] is the sub-list for method output_type
	19, // [19:23] is the sub-list for method input_type
	19, // [19:19] is the sub-list for extension type_name
	19, // [19:19] is the sub-list for extension extendee
	0,  // [0:19] is the sub-list for field type_name
}

func init() { file_datapower_noesis_v1_sidecar_proto_init() }
func file_datapower_noesis_v1_sidecar_proto_init() {
	if File_datapower_noesis_v1_sidecar_proto != nil {
		return
	}
	file_datapower_noesis_v1_connector_proto_init()
	file_datapower_noesis_v1_sidecar_proto_msgTypes[0].OneofWrappers = []any{
		(*InitSessionRequest_ParquetConfig)(nil),
		(*InitSessionRequest_IcebergConfig)(nil),
		(*InitSessionRequest_DeltaConfig)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_datapower_noesis_v1_sidecar_proto_rawDesc), len(file_datapower_noesis_v1_sidecar_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_datapower_noesis_v1_sidecar_proto_goTypes,
		DependencyIndexes: file_datapower_noesis_v1_sidecar_proto_depIdxs,
		EnumInfos:         file_datapower_noesis_v1_sidecar_proto_enumTypes,
		MessageInfos:      file_datapower_noesis_v1_sidecar_proto_msgTypes,
	}.Build()
	File_datapower_noesis_v1_sidecar_proto = out.File
	file_datapower_noesis_v1_sidecar_proto_goTypes = nil
	file_datapower_noesis_v1_sidecar_proto_depIdxs = nil
}
